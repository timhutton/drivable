<!DOCTYPE HTML>
<html>
<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<style>
    body {
        margin: 10px;
        padding: 0px;
    }
</style>
</head>
<body>
<p>
Grab a truck to slide it left and right. It turns red if it is blocked.
</p>

<p>
On the right we plot with a blue dot the two truck positions as x and y. The lines are the constraints showing
where the trucks collide. Click on the plot to change the variables directly.
</p>

<p>
The whole idea here is that we don't need to do collision detection at runtime since the constraints tell us everything we need to know about the movement. We are exploring the class of systems for which this concept remains useful.
</p>

<canvas id="myCanvas" width="1200" height="700"></canvas>
<script>

function getTruckRect(i) {
    return { x:variables[i]-truck_width/2, y: truck_top, w:truck_width, h:truck_height };
}
function getPartLabel(i) {
    return String.fromCharCode(65+i);
}
function projectPlotToScreen( p, i ) {
    return new Point(p.x*plot_scale + area_width+margin*2, (area_width-p.y)*plot_scale+margin + (area_width*plot_scale+margin)*i );
}
function projectScreenToPlot( p, i ) {
    return new Point( (p.x - (area_width+margin*2))/plot_scale, area_width - (p.y-margin-(area_width*plot_scale+margin)*i)/plot_scale );
}
function projectAreaToScreen( p ) {
    return new Point(p.x+margin, p.y+margin );
}
function projectScreenToArea( p ) {
    return new Point(p.x-margin, p.y-margin );
}
function draw(canvas) {
    var context = canvas.getContext('2d');

    // show the limit of the canvas itself
    context.beginPath();
    context.rect(0, 0, canvas.width, canvas.height);
    context.fillStyle = '#F0F0F0';
    context.fill();
    
    // show the collision area
    context.beginPath();
    var a = projectAreaToScreen( new Point(0,0) );
    var b = projectAreaToScreen( new Point(area_width,area_height) );
    context.rect( a.x, a.y, b.x-a.x, b.y-a.y );
    context.fillStyle = 'white';
    context.fill();
    context.lineWidth = 1;
    context.strokeStyle = 'black';
    context.stroke();
    
    // draw each truck as a rectangle
    for( var i = 0; i < N_VARIABLES; i++ ) {
        context.beginPath();
        var r = getTruckRect(i);
        var a = projectAreaToScreen( new Point( r.x, r.y ) );
        var b = projectAreaToScreen( new Point( r.x + r.w, r.y + r.h) );
        context.rect( a.x, a.y, b.x-a.x, b.y-a.y );
        if( i == iDriver ) {
            if( currentMousePositionAccepted )
                context.fillStyle = 'limegreen';
            else
                context.fillStyle = 'red';
        }
        else
            context.fillStyle = 'grey';
        context.fill();
        context.lineWidth = 1;
        context.strokeStyle = 'black';
        context.stroke();
        
        context.font = "30px Arial";
        context.textAlign = "center";
        context.fillStyle = "black";
        context.fillText( getPartLabel(i), (a.x+b.x)/2, (a.y+b.y)/2+10 );
   }
    
    // plot
    for( var iPlotConnection = 0; iPlotConnection < N_CONNECTIONS; iPlotConnection++ ) {
        var connection = connections[ iPlotConnection ];
        // blank the plot area
        context.beginPath();
        var a = projectPlotToScreen( new Point(0,0), iPlotConnection );
        var b = projectPlotToScreen( new Point(area_width, area_width), iPlotConnection );
        context.rect( a.x, a.y, b.x-a.x, b.y-a.y );
        context.fillStyle = 'white';
        context.fill();
        // label the axes
        var horiz_axis_label_pos = projectPlotToScreen( new Point( area_width/2, area_width ), iPlotConnection );
        var vert_axis_label_pos = projectPlotToScreen( new Point( 0, area_width/2 ), iPlotConnection );
        context.font = "12px Arial";
        context.textAlign = "center";
        context.fillStyle = "black";
        context.fillText( getPartLabel(connection.a), horiz_axis_label_pos.x, horiz_axis_label_pos.y );
        context.fillText( getPartLabel(connection.b), vert_axis_label_pos.x, vert_axis_label_pos.y );
        // draw the current state as a blue dot
        var connection = connections[iPlotConnection];
        var p = new Point( variables[connection.a], variables[connection.b] );
        var pp = projectPlotToScreen( p, iPlotConnection );
        context.beginPath();
        context.arc(pp.x, pp.y, 3, 0, 2*Math.PI);
        context.fillStyle = 'blue';
        context.fill();
        // draw the constraints
        for( var iSegmentGroup = 0; iSegmentGroup < connection.connected_segments.length; iSegmentGroup++) {
            var segment_group = connection.connected_segments[ iSegmentGroup ];
            for( var iSegment = 0; iSegment < segment_group.constraints.length; iSegment++) {
                var segment = segment_group.constraints[iSegment].segment;
                context.beginPath();
                var a = projectPlotToScreen( segment.p1, iPlotConnection );
                var b = projectPlotToScreen( segment.p2, iPlotConnection );
                context.moveTo( a.x, a.y);
                context.lineTo( b.x, b.y );
                context.lineWidth = 1;
                context.strokeStyle = 'black';
                context.stroke();
            }
        }
    }
}

// return true if we were able to perform the whole move
function tryMoveDriver2( areaPos ) {
    var new_value = areaPos.x; // (for now, specific to horizontal trucks)
    var moved = new Array( N_VARIABLES );
    for( var i = 0; i < N_VARIABLES; i++ )
        moved[ i ] = false;
    moved[ iDriver ] = true;
    return tryChangeVariable( iDriver, new_value, moved );
}

function tryChangeVariable( iVariable, new_value, moved ) {
    while(1) {
        // Find the first constraint that intersects this change (in any connection that this variable has with a not moved variable)
        var iOtherVariable = 0; // TODO
        // If none then set this variable to new_value and return true.
        // If friction jam then set this variable to the jam point and return false.
        // Else is slide (to end or partial). Set iVariable to slideEnd value and retrieve the other_value for the other variable
        var other_value = 0; // TODO
        moved[ iVariable ] = true;
        var ok = tryChangeVariable( iOtherVariable, other_value, moved );
        if( !ok ) return false; // one of the other parts jammed
        // so now we have navigated past the first constraint and we have made some progress towards new_value
        // if was partial slide then can return true (was limited only by how far we wanted to go)
        // else try this all again
        // (maybe check here that we did make *some* progress, else may loop forever)
    }
}

function tryMoveDriver( areaPos ) {
    // the mouse drives the variable indexed by iDriver
    var old_value = variables[iDriver];
    var new_value = areaPos.x; 
    // for each connection that involves this variable, construct the line segment in the state
    // space of the two variables that this move represents, and see if it intersects any constraints
    for( var iConnection = 0; iConnection < N_CONNECTIONS; iConnection++ ) {
        var connection = connections[iConnection];
        var moveSegment;
        if( connection.a == iDriver )
            moveSegment = new LineSegment( new Point( old_value, variables[ connection.b ] ), new Point( new_value, variables[ connection.b ] ) );
        else if( connection.b == iDriver )
            moveSegment = new LineSegment( new Point( variables[ connection.a ], old_value ), new Point( variables[ connection.a ], new_value ) );
        else
            continue;
        for( var iSegmentGroup = 0; iSegmentGroup < connection.connected_segments.length; iSegmentGroup++) {
            var constraint_group = connection.connected_segments[ iSegmentGroup ];
            for( var iConstraint = 0; iConstraint < constraint_group.constraints.length; iConstraint++ ) {
                var cr = testConstraint( moveSegment, constraint_group.constraints, iConstraint );
                if( !cr.hit ) continue;
                if( cr.jam ) {
                    variables[ connection.a ] = cr.jamPoint.x;
                    variables[ connection.b ] = cr.jamPoint.y;
                    return false;
                }
                if( connection.a == iDriver ) {
                    new_value = cr.slide.p2.x;
                    variables[ connection.b ] = cr.slide.p2.y;
                }
                else if( connection.b == iDriver ) {
                    new_value = cr.slide.p2.y;
                    variables[ connection.a ] = cr.slide.p2.x;
                }
            }
        }
    }
    // TODO: deal with the implications for the parts that are not directly connected
    
    variables[iDriver] = new_value;
    return true;
}

function getMousePos(canvas, evt) {
    var rect = canvas.getBoundingClientRect();
    return {
        x: evt.clientX - rect.left,
        y: evt.clientY - rect.top
    };
}
var canvas = document.getElementById('myCanvas');
var context = canvas.getContext('2d');

// A drivable constraint is a line segment in the 2D space of two variables
// representing a contact between two pieces. (Could generalize to curve segments.)
// If your intended step takes you across the segment then it steers you to
// one side or the other. if you meet it at right-angles then you get stuck
// and can go no further. (For parts with more than one way of moving (e.g. sliding cogs)
// a drivable constraint would be a patch of surface but we ignore such cases for now.)

// A tricky question is how to compute these segments for a set of moving parts.
// But if we know the segments then we can use them and let the user move the parts around.
// So for now we manually specify a list of segments.

// Each part has (for now) one variable that controls how it can move. e.g. a truck has a single
// position, a rotating arm has an angle.
// If two parts are capable of directly interacting then they have a connection. A connection is a list
// of drivable constraints.

function Point(x,y) {
    this.x = x;
    this.y = y;
}
function LineSegment(p1,p2) {
    this.p1 = p1;
    this.p2 = p2;
}
function isBehind( point, constraint ) {
    var dp = dot( norm( sub( point, constraint.p1 ) ), norm( perp( sub( constraint.p2, constraint.p1 ) ) ) );
    return dp < -epsilon; // (allow for floating point issues)
}
function perp( v ) {
    return new Point( -v.y, v.x );
}
function norm( v ) {
    var vl = Math.hypot( v.x, v.y );
    return new Point( v.x / vl, v.y / vl );
}
function add( a, b ) {
    return new Point( a.x + b.x, a.y + b.y );
}
function sub( a, b ) {
    return new Point( a.x - b.x, a.y - b.y );
}
function dot( a, b ) {
    return a.x * b.x + a.y * b.y;
}
function lerp( a, b, u ) {
    return new Point( a.x + u * (b.x - a.x), a.y + u * (b.y - a.y) );
}
function pointInRect( p, r ) {
    return p.x >= r.x && p.x <= r.x + r.w && p.y >= r.y && p.y <= r.y + r.h;
}
// for a LineSegment 'move' we test whether it hits the constraint.
// We return an object { hit:bool, jam:bool, before:LineSegment, slide:LineSegment }
// where the segments are null if hit is false or jam or true
function testConstraint( move, constraints, iConstraint ) {
    var constraint = constraints[iConstraint];
    // a move is a collision if:
    // 1. the move segment intersects the constraint segment
    // 2. the end of the move is behind the constraint segment
    // 3. the start of the move is not behind the constraint segment
    // 4. the resulting slide would leave the start in a different place
    var intersection = lineSegmentsIntersection( move, constraint.segment );
    var endIsBehind = isBehind( move.p2, constraint.segment );
    var startIsBehind = isBehind( move.p1, constraint.segment );
    if( !intersection.test || !endIsBehind || startIsBehind ) {
        //console.log("no collision");
        return { hit:false };
    }
    var gradient = getGradientForConstraint( move, constraint.segment );
    if( Math.abs( gradient ) < minGradient ) {
        console.log("friction jam");
        return { hit:true, jam:true, jamPoint:intersection.point };
    }
    var beforeSegment = new LineSegment( move.p1, intersection.point );
    var slide_intersection = lineSegmentWithLineIntersection( constraint.segment, move.p2, perp( sub( move.p2, move.p1 ) ) );
    if( slide_intersection.test ) {
        console.log("partial slide");
        var slideEnd = slide_intersection.point;
        return { hit:true, jam:false, before:beforeSegment, slide: new LineSegment( intersection.point, slideEnd ) };
    }
    // if we slid to the end, check that the next segment in the sequence has a favorable gradient
    // else this is a jam position
    var slideEnd = null;
    var neighboring_constraint = null;
    var has_neighbor = false;
    if( gradient < 0 ) {
        slideEnd = constraint.segment.p1;
        if( constraint.connected_to_previous ) {
            has_neighbor = true;
            neighboring_constraint = constraints[ ( iConstraint - 1 + constraints.length ) % constraints.length ];
        }
    }
    else {
        slideEnd = constraint.segment.p2;
        if( constraint.connected_to_next ) {
            has_neighbor = true;
            neighboring_constraint = constraints[ ( iConstraint + 1 ) % constraints.length ];
        }
    }
    var slideSegment = new LineSegment( intersection.point, slideEnd );
    var neighboring_gradient = null;
    if( has_neighbor )
        neighboring_gradient = getGradientForConstraint( move, neighboring_constraint.segment );
    if( has_neighbor && Math.abs( neighboring_gradient ) < minGradient ) {
        console.log("slide to friction jam");
        return { hit:true, jam:true, jamPoint:slideEnd };
    }
    if( !has_neighbor || ( neighboring_gradient < 0 && gradient < 0 ) || ( neighboring_gradient > 0 && gradient > 0 ) ) {
        if( Math.hypot( slideEnd.x - move.p1.x, slideEnd.y - move.p1.y ) < epsilon ) {
            console.log("no collision - would slide to the same place as we started");
            return { hit:false };
        }
        console.log("slide to end");
        return { hit:true, jam:false, before:beforeSegment, slide:slideSegment };
    }
    console.log("slide to corner jam");
    return { hit:true, jam:true, jamPoint:slideEnd };
}
function lineSegmentsIntersection(s1,s2) {
    return lineSegmentsIntersection2(s1.p1.x,s1.p1.y,s1.p2.x,s1.p2.y,s2.p1.x,s2.p1.y,s2.p2.x,s2.p2.y);
}
function lineSegmentsIntersection2(a,b,c,d,p,q,r,s) {
  var det, gamma, lambda;
  det = (c - a) * (s - q) - (r - p) * (d - b);
  if (det === 0) {
    return { test:false };
  } else {
    lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;
    gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;
    var intersects = (-epsilon <= lambda && lambda <= 1+epsilon) && (-epsilon <= gamma && gamma <= 1+epsilon);
    var p = lerp( new Point(a,b), new Point(c,d), lambda );
    return { test:intersects, point:p };
  }
}
function lineSegmentWithLineIntersection( s, p2, v2 ) {
    return lineSegmentWithLineIntersection2( s.p1.x, s.p1.y, s.p2.x, s.p2.y, p2.x, p2.y, p2.x+v2.x, p2.y+v2.y );
}
function lineSegmentWithLineIntersection2( a,b,c,d,p,q,r,s ) {
  var det, gamma, lambda;
  det = (c - a) * (s - q) - (r - p) * (d - b);
  if (det === 0) {
    return { test:false };
  } else {
    lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;
    gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;
    var intersects = (-epsilon <= lambda && lambda <= 1+epsilon);
    var p = lerp( new Point(a,b), new Point(c,d), lambda );
    return { test:intersects, point:p };
  }
}
function getGradientForConstraint( move, constraint ) {
    return dot( sub( move.p2, move.p1 ), sub( constraint.p2, constraint.p1 ) );
}

var N_VARIABLES = 2;
var variables = new Array(N_VARIABLES);
for( var i = 0; i < N_VARIABLES; i++ )
    variables[i] = 100 * (i+1);

var N_PARTS = N_VARIABLES; // (for now)

function Connection(a,b) {
    this.a = a; // this indexed variable is the x-coordinate
    this.b = b; // this indexed variable is the y-coordinate
    this.connected_segments = [];
}
function ConnectedSegmentGroup() {
    this.constraints = [];
}
function Constraint(s,cp,cn) {
    this.segment = s;
    this.connected_to_previous = cp;
    this.connected_to_next = cn;
}

var truck_width = 60;
var truck_height = 40;
var truck_top = 200;
var area_width = 700;
var area_height = 400;
var minGradient = 0.1;
var epsilon = 1E-6; // for floating-point issues

var N_CONNECTIONS = N_PARTS-1;
var plot_scale = canvas.height / ( area_width * N_PARTS );
var margin = 20;

var connections = new Array(N_CONNECTIONS);

// stop the trucks passing through each other or the wall
for( var i = 0; i < N_CONNECTIONS; i++ ) {
    connections[i] = new Connection(i,i+1); 
    var group = new ConnectedSegmentGroup(); // within a group, constraints join onto each other in sequence
    if( N_CONNECTIONS == 1 ) {
        var leftWall = new Constraint( new LineSegment( new Point( truck_width/2, area_width - truck_width/2 ),
                                                        new Point( truck_width/2, truck_width + truck_width/2 ) ),
                                       true,
                                       true );
        group.constraints.push( leftWall );
        var trucksPush = new Constraint( new LineSegment( new Point( truck_width/2, truck_width + truck_width/2 ),
                                                          new Point( area_width - truck_width*3/2, area_width - truck_width/2) ),
                                         true,
                                         true );
        group.constraints.push( trucksPush );
        var rightWall = new Constraint( new LineSegment( new Point( area_width - truck_width*3/2, area_width-truck_width/2 ),
                                                         new Point( truck_width/2, area_width-truck_width/2 ) ),
                                        true,
                                        true );
        group.constraints.push( rightWall );
    }
    if( i == 0 ) {
        var leftWall = new Constraint( new LineSegment( new Point( truck_width/2, area_width - truck_width/2 ),
                                                        new Point( truck_width/2, truck_width + truck_width/2 ) ),
                                       false,
                                       true );
        group.constraints.push( leftWall );
        var trucksPush = new Constraint( new LineSegment( new Point( truck_width/2, truck_width + truck_width/2 ),
                                                          new Point( area_width - truck_width*3/2, area_width - truck_width/2) ),
                                         true,
                                         false );
        group.constraints.push( trucksPush );
    }
    else if( i == N_CONNECTIONS-1 ) {
        var trucksPush = new Constraint( new LineSegment( new Point( truck_width/2, truck_width + truck_width/2 ),
                                                          new Point( area_width - truck_width*3/2, area_width - truck_width/2 ) ),
                                         false,
                                         true );
        group.constraints.push( trucksPush );
        var rightWall = new Constraint( new LineSegment( new Point( area_width - truck_width*3/2, area_width-truck_width/2 ),
                                                         new Point( truck_width/2, area_width-truck_width/2 ) ),
                                        true,
                                        false );
        group.constraints.push( rightWall );
    }
    else {
        var trucksPush = new Constraint( new LineSegment( new Point(truck_width/2,truck_width+truck_width/2),
                                                          new Point(area_width-truck_width*3/2,area_width-truck_width/2) ),
                                         false,
                                         false );
        group.constraints.push( trucksPush );
    }
    connections[i].connected_segments.push( group );
}
    
// one truck is the driver
var iDriver = -1; // -1 means nothing is currently the driver
var currentMousePositionAccepted = true;
draw(canvas);

canvas.addEventListener('mousedown', function(evt) {
    var mousePos = getMousePos(canvas, evt);
    // if within a shape then make it the driver
    var areaPos = projectScreenToArea( mousePos );
    for( var iPart = 0; iPart < N_PARTS; iPart++ ) {
        if( pointInRect( areaPos, getTruckRect( iPart ) ) ) {
            iDriver = iPart;
            draw(canvas);
            return;
        }
    }
    // if on a plot then set those variables directly
    for( var iPlotConnection = 0; iPlotConnection < N_CONNECTIONS; iPlotConnection++ ) {
        var plotPos = projectScreenToPlot( mousePos, iPlotConnection );
        if( pointInRect( plotPos, {x:0,y:0,w:area_width,h:area_width} ) )
        {
            var connection = connections[ iPlotConnection ];
            variables[ connection.a ] = plotPos.x;
            variables[ connection.b ] = plotPos.y;
            draw(canvas);
            return;
        }
    }
}, false);

canvas.addEventListener('mousemove', function(evt) {
    if( iDriver < 0 ) return;
    var mousePos = getMousePos(canvas, evt);
    var areaPos = projectScreenToArea( mousePos );
    currentMousePositionAccepted = tryMoveDriver( areaPos );
    draw(canvas);
}, false);

canvas.addEventListener('mouseup', function(evt) {
    iDriver = -1;
    draw(canvas);
}, false);

</script>
</body>
</html>
