<!DOCTYPE HTML>
<html>
<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<style>
    body {
        margin: 10px;
        padding: 0px;
    }
</style>
</head>
<body>
<p>Grab a truck to slide it left and right. It turns red if it is blocked.</p>

<p>On the right is a set of truck pairs, showing the constraints that exist between them. We plot with a blue dot the two truck positions as x and y. Click on the plot to change the variables directly.</p>

<p>The whole idea here is that we don't need to do collision detection at runtime since the constraints tell us everything we need to know about the movement. We are exploring the class of systems for which this concept remains useful.</p>
<canvas id="myCanvas" width="1200" height="700"></canvas>
<script>

// -----------------------------------------------------------------------------------

// If the positions of parts are controlled by variables, then a drivable constraint is 
// a line segment in the 2D space of two variables representing a physical contact between 
// two pieces. (Could generalize to curve segments.)
// If your intended step takes you across the constraint segment then it steers you to
// one side or the other. If you meet it at right-angles then you get stuck
// and can go no further. (For parts with more than one way of moving (e.g. sliding cogs)
// a drivable constraint would be a patch of surface but we ignore such cases for now.)

// A tricky question is how to compute these segments for a set of moving parts.
// But if we know the segments then we can use them and let the user move the parts around.
// So for now we manually specify a list of segments.

// Each part has (for now) one variable that controls how it can move. e.g. a truck has a single
// position, a rotating arm has an angle.
// If two parts are capable of directly interacting then they have a connection. A connection is a list
// of drivable constraints.

// -----------------------------------------------------------------------------------

var area_width = 700;
var area_height = 400;
var minGradient = 0.1;
var epsilon = 1E-6; // for floating-point issues
var margin = 20; // pixels

var canvas = document.getElementById('myCanvas');
var context = canvas.getContext('2d');
var iDrivenVariable = -1;
var currentMousePositionAccepted = true;
var grabPos = null;
var isMouseDown = false;

var N_PARTS = null;
var N_CONNECTIONS = null;
var N_VARIABLES = null;
var parts = null;
var connections = null;
var variables = null;
var plot_scale = null;

var CollisionOutcome = {
    MISS:                  1,
    FRICTION_JAM:          2,
    PARTIAL_SLIDE:         3,
    SLIDE_TO_END:          4,
    SLIDE_TO_FRICTION_JAM: 5,
    SLIDE_TO_CORNER_JAM:   6
};

// -----------------------------------------------------------------------------------

initWithTrucks(5);
//initWithTest();
draw(canvas);

// -----------------------------------------------------------------------------------

function initWithTest() {
    N_VARIABLES = 2;
    N_PARTS = 2;
    var N = 10;
    
    parts = new Array( N_PARTS );
    {
        //var poly = [ new Point( 200, 200 ), new Point( 150, 150 ), new Point( 200, 150 ) ];
        var poly = new Array(N);
        for( var i = 0; i < N; i++ )
            poly[i] = new Point( 100 + 50*Math.cos(i*2*Math.PI/N), 100 + 50*Math.sin(i*2*Math.PI/N) );
        var initial_transform = new Transform(0,new Point(0,0));
        var label = "A";
        var variables_that_affect_us = [ 0 ];
        parts[0] = new Part( label, poly, initial_transform, variables_that_affect_us );
    }
    {
        //var poly = [ new Point( 300, 300 ), new Point( 350, 300 ), new Point( 350, 350 ) ];
        var poly = new Array(N);
        for( var i = 0; i < N; i++ )
            poly[i] = new Point( 300 + 25*Math.cos(i*2*Math.PI/N), 300 + 100*Math.sin(i*2*Math.PI/N) );
        var initial_transform = new Transform(0,new Point(0,0));
        var label = "B";
        var variables_that_affect_us = [ 1 ];
        parts[1] = new Part( label, poly, initial_transform, variables_that_affect_us );
    }
    
    // each variable applies to a part, and transforms it in some way
    variables = new Array(N_VARIABLES);
    {
        var initial_value = 0;
        var transform = new Transform( 0, new Point(0.5,0.15) );
        var iPart = 0;
        var label = parts[ iPart ].label; // (if this part had more than one variable then would need to disambiguate)
        var min_value = 0;
        var max_value = 1000;
        variables[0] = new Variable( label, iPart, initial_value, transform, min_value, max_value );
    }    
    {
        var initial_value = 0;
        var transform = new Transform( 0, new Point(-0.1,-0.5) );
        var iPart = 1;
        var label = parts[ iPart ].label; // (if this part had more than one variable then would need to disambiguate)
        var min_value = 0;
        var max_value = 1000;
        variables[1] = new Variable( label, iPart, initial_value, transform, min_value, max_value );
    }    

    N_CONNECTIONS = 1;
    plot_scale = Math.min( canvas.height - margin*(N_CONNECTIONS+1), canvas.width - area_width - margin*3 ) / ( area_width * N_CONNECTIONS );

    connections = new Array(N_CONNECTIONS);
    connections[0] = computeConstraints( 0, 1 );
}

// -----------------------------------------------------------------------------------

function computeConstraints( iVar1, iVar2 ) {
    
    var connection = new Connection( iVar1, iVar2 );
    var group = new ConnectedSegmentGroup(); // within a group, constraints join onto each other in sequence
    var var1 = variables[ iVar1 ];
    var var2 = variables[ iVar2 ];
    var part1 = parts[ var1.iPart ];
    var part2 = parts[ var2.iPart ];
    var poly1 = new Array( part1.poly.length );
    for( var i = 0; i < part1.poly.length; i++ ) {
        poly1[i] = applyTransform( part1.poly[i], part1.initial_transform, 1 );
    }
    var poly2 = new Array( part2.poly.length );
    for( var i = 0; i < part2.poly.length; i++ ) {
        poly2[i] = applyTransform( part2.poly[i], part2.initial_transform, 1 );
    }
    // (TODO: move this into a function
    var v1 = var1.transform.translation; // TODO: rotations
    var v2 = var2.transform.translation; // TODO: rotations
    
    // make constraints from each (line segment, point) pair
    for( var iPt1 = 0; iPt1 < poly1.length; iPt1++ ) {
        var p1 = poly1[ iPt1 ];
        var seg1L = new LineSegment( poly1[ (iPt1+poly1.length-1)%poly1.length ], p1 );
        var seg1R = new LineSegment( p1, poly1[ (iPt1+1)%poly1.length ] );
        var seg1LN = norm( perp( sub( seg1L.p2, seg1L.p1 ) ) );
        var seg1RN = norm( perp( sub( seg1R.p2, seg1R.p1 ) ) );
        var p1N = norm( add( seg1LN, seg1RN ) );
        for( var iPt2 = 0; iPt2 < poly2.length; iPt2++ ) {
            var p2 = poly2[ iPt2 ];
            var seg2L = new LineSegment( poly2[ (iPt2+poly2.length-1)%poly2.length ], p2 );
            var seg2R = new LineSegment( p2, poly2[ (iPt2+1)%poly2.length ] );
            var seg2LN = norm( perp( sub( seg2L.p2, seg2L.p1 ) ) );
            var seg2RN = norm( perp( sub( seg2R.p2, seg2R.p1 ) ) );
            var p2N = norm( add( seg2LN, seg2RN ) );
            if( dot( p2N, seg1RN ) < 0 ) {
                var constraint_segment = getConstraintSegmentFromLineSegmentAndPoint( seg1R, v1, p2, v2 );
                group.constraints.push( new Constraint( constraint_segment, false, false ) );
            }
            if( dot( p1N, seg2RN ) < 0 ) {
                var constraint_segment = getConstraintSegmentFromLineSegmentAndPoint( seg2R, v2, p1, v1 );
                constraint_segment.p1 = reflectXY( constraint_segment.p1 );
                constraint_segment.p2 = reflectXY( constraint_segment.p2 );
                group.constraints.push( new Constraint( constraint_segment, false, false ) );
            }
        }
    }
    connection.connected_segments.push( group );
    
    return connection;
}

// -----------------------------------------------------------------------------------

function reflectXY(p) {
    return new Point(p.y,p.x);
}

// -----------------------------------------------------------------------------------

function getConstraintSegmentFromLineSegmentAndPoint( segment, v1, p, v2 ) {
    // if the segment moves along v1 and the point along v2,
    // how far along each will they be at the moments where the endpoints intersect with the point?
    var intersection1 = lineWithLineIntersection( segment.p1, v1, p, v2 );
    var intersection2 = lineWithLineIntersection( segment.p2, v1, p, v2 );
    if( !intersection1.test || !intersection2.test )
        return null; // v1 and v2 are parallel
    return new LineSegment( new Point( intersection2.u1, intersection2.u2 ),
                            new Point( intersection1.u1, intersection1.u2 ) );
}

// -----------------------------------------------------------------------------------

function initWithTrucks( numTrucksWanted ) {
    var truck_width = 60;
    var truck_height = 40;
    var truck_top = 200;
    
    N_VARIABLES = numTrucksWanted;
    N_PARTS = N_VARIABLES; // (for now each part has a single degree of freedom)

    // each part is a polygon, centered at its rotation point
    parts = new Array( N_PARTS );
    for( var iPart = 0; iPart < N_PARTS; iPart++ ) {
        var poly = [ new Point(-truck_width/2,-truck_height/2), new Point(truck_width/2,-truck_height/2),
                     new Point(truck_width/2,truck_height/2),   new Point(-truck_width/2,truck_height/2) ];
        var initial_transform = new Transform( 0, new Point(0,truck_top) );
        var label = String.fromCharCode( 65 + iPart );
        var variables_that_affect_us = [ iPart ];
        parts[iPart] = new Part( label, poly, initial_transform, variables_that_affect_us );
    }

    // each variable applies to a part, and transforms it in some way
    variables = new Array(N_VARIABLES);
    for( var iVariable = 0; iVariable < N_VARIABLES; iVariable++ ) {
        var initial_value = (iVariable+1) * area_width / (N_PARTS+1);
        var transform = new Transform( 0, new Point(1,0) );
        var iPart = iVariable;
        var label = parts[ iPart ].label; // (if this part had more than one variable then would need to disambiguate)
        var min_value = 0;
        var max_value = area_width;
        variables[iVariable] = new Variable( label, iPart, initial_value, transform, min_value, max_value );
    }    

    N_CONNECTIONS = N_PARTS-1;
    plot_scale = ( canvas.height - margin*(N_CONNECTIONS+1) ) / ( area_width * N_CONNECTIONS );

    // stop the trucks passing through each other or the wall
    connections = new Array(N_CONNECTIONS);
    for( var i = 0; i < N_CONNECTIONS; i++ ) {
        connections[i] = new Connection(i,i+1); 
        var group = new ConnectedSegmentGroup(); // within a group, constraints join onto each other in sequence
        if( N_CONNECTIONS == 1 ) {
            var leftWall = new Constraint( new LineSegment( new Point( truck_width/2, area_width - truck_width/2 ),
                                                            new Point( truck_width/2, truck_width + truck_width/2 ) ),
                                           true,
                                           true );
            group.constraints.push( leftWall );
            var trucksPush = new Constraint( new LineSegment( new Point( truck_width/2, truck_width + truck_width/2 ),
                                                              new Point( area_width - truck_width*3/2, area_width - truck_width/2) ),
                                             true,
                                             true );
            group.constraints.push( trucksPush );
            var rightWall = new Constraint( new LineSegment( new Point( area_width - truck_width*3/2, area_width-truck_width/2 ),
                                                             new Point( truck_width/2, area_width-truck_width/2 ) ),
                                            true,
                                            true );
            group.constraints.push( rightWall );
        }
        else if( i == 0 ) {
            var leftWall = new Constraint( new LineSegment( new Point( truck_width/2, area_width - truck_width/2 ),
                                                            new Point( truck_width/2, truck_width + truck_width/2 ) ),
                                           false,
                                           true );
            group.constraints.push( leftWall );
            var trucksPush = new Constraint( new LineSegment( new Point( truck_width/2, truck_width + truck_width/2 ),
                                                              new Point( area_width - truck_width*3/2, area_width - truck_width/2) ),
                                             true,
                                             false );
            group.constraints.push( trucksPush );
        }
        else if( i == N_CONNECTIONS-1 ) {
            var trucksPush = new Constraint( new LineSegment( new Point( truck_width/2, truck_width + truck_width/2 ),
                                                              new Point( area_width - truck_width*3/2, area_width - truck_width/2 ) ),
                                             false,
                                             true );
            group.constraints.push( trucksPush );
            var rightWall = new Constraint( new LineSegment( new Point( area_width - truck_width*3/2, area_width-truck_width/2 ),
                                                             new Point( truck_width/2, area_width-truck_width/2 ) ),
                                            true,
                                            false );
            group.constraints.push( rightWall );
        }
        else {
            var trucksPush = new Constraint( new LineSegment( new Point(truck_width/2,truck_width+truck_width/2),
                                                              new Point(area_width-truck_width*3/2,area_width-truck_width/2) ),
                                             false,
                                             false );
            group.constraints.push( trucksPush );
        }
        connections[i].connected_segments.push( group );
    }
}
    
// -----------------------------------------------------------------------------------

function Part( label, poly, initial_transform, variables_that_affect_us ) {
    this.label = label;
    this.poly = poly;
    this.initial_transform = initial_transform;
    this.variables_that_affect_us = variables_that_affect_us;
 }
 
// -----------------------------------------------------------------------------------

function Transform( rotation, translation ) {
    this.rotation = rotation;
    this.translation = translation;
 }
 
// -----------------------------------------------------------------------------------

function Variable( label, iPart, initial_value, transform, min_value, max_value ) {
    this.label = label;
    this.iPart = iPart;
    this.value = initial_value;
    this.transform = transform;
    this.min_value = min_value;
    this.max_value = max_value;
}

// -----------------------------------------------------------------------------------

canvas.addEventListener('mousedown', function(evt) {
    isMouseDown = true;
    var mousePos = getMousePos(canvas, evt);
    // if within a shape then make it the driver
    var areaPos = projectScreenToArea( mousePos );
    var iVariable = getVariableHandleByAreaPos( areaPos );
    if( iVariable >= 0 ) {
        iDrivenVariable = iVariable;
        grabPos = areaPos;
        draw();
        drawVariableHandle( iDrivenVariable, areaPos );
        return;
    }
    // if on a plot then set those variables directly
    for( var iPlotConnection = 0; iPlotConnection < N_CONNECTIONS; iPlotConnection++ ) {
        var plotPos = projectScreenToPlot( mousePos, iPlotConnection );
        if( pointInRect( plotPos, {x:0,y:0,w:area_width,h:area_width} ) )
        {
            var connection = connections[ iPlotConnection ];
            variables[ connection.a ].value = plotPos.x;
            variables[ connection.b ].value = plotPos.y;
            draw();
            return;
        }
    }
}, false);

// -----------------------------------------------------------------------------------

canvas.addEventListener('mousemove', function(evt) {
    var mousePos = getMousePos(canvas, evt);
    var areaPos = projectScreenToArea( mousePos );
    if( isMouseDown ) {
        if( iDrivenVariable < 0 ) return;
        currentMousePositionAccepted = tryMoveDriver( grabPos, areaPos );
        if( currentMousePositionAccepted ) {
            grabPos = areaPos;
            // TODO: this is not quite right - the truck might have moved a little even if was blocked from going the whole way
            //       result is slight cursor drift from the attachment point
        }
    }
    else {
        iDrivenVariable = getVariableHandleByAreaPos( areaPos );
        currentMousePositionAccepted = true;
    }
    draw();
    drawVariableHandle( iDrivenVariable, areaPos );
}, false);

// -----------------------------------------------------------------------------------

canvas.addEventListener('mouseup', function(evt) {
    isMouseDown = false;
    currentMousePositionAccepted = true;
    var mousePos = getMousePos(canvas, evt);
    var areaPos = projectScreenToArea( mousePos );
    iDrivenVariable = getVariableHandleByAreaPos( areaPos );
    draw();
    drawVariableHandle( iDrivenVariable, areaPos );
}, false);

// -----------------------------------------------------------------------------------

function getVariableHandleByAreaPos( areaPos ) {
    for( var iVariable = N_VARIABLES-1; iVariable >= 0; iVariable-- ) {
        if( pointInPolygon( getTransformedPart( variables[ iVariable ].iPart ), areaPos ) )
            return iVariable;
    }
    return -1;
}

// -----------------------------------------------------------------------------------

function getTransformedPart( iPart ) {
    var tp = [];
    var part = parts[ iPart ];
    for( var iPt = 0; iPt < part.poly.length; iPt++ ) {
        tp.push( applyPartTransform( iPart, part.poly[iPt] ) );
    }
    return tp;
}

// -----------------------------------------------------------------------------------

function projectAreaToScreen( p ) {
    return new Point(p.x+margin, p.y+margin );
}

// -----------------------------------------------------------------------------------

function projectScreenToArea( p ) {
    return new Point(p.x-margin, p.y-margin );
}

// -----------------------------------------------------------------------------------

function projectPlotToScreen( p, i ) {
    return new Point( p.x*plot_scale + area_width+margin*2, 
                      (area_width*plot_scale+margin)*i + margin + (area_width-p.y)*plot_scale  );
}

// -----------------------------------------------------------------------------------

function projectScreenToPlot( p, i ) {
    return new Point( ( p.x - (area_width+margin*2) ) / plot_scale, 
                      area_width - (p.y - (area_width*plot_scale+margin)*i - margin ) / plot_scale );
}

// -----------------------------------------------------------------------------------

function draw() {
    // show the limit of the canvas itself
    context.beginPath();
    context.rect(0, 0, canvas.width, canvas.height);
    context.fillStyle = '#F0F0F0';
    context.fill();
    
    // show the collision area
    context.beginPath();
    var a = projectAreaToScreen( new Point(0,0) );
    var b = projectAreaToScreen( new Point(area_width,area_height) );
    context.rect( a.x, a.y, b.x-a.x, b.y-a.y );
    context.fillStyle = 'white';
    context.fill();
    context.lineWidth = 1;
    context.strokeStyle = 'black';
    context.stroke();
    
    // draw each part
    for( var iPart = 0; iPart < N_PARTS; iPart++ ) {
        drawPart( iPart );
    }

    // plot
    for( var iPlotConnection = 0; iPlotConnection < N_CONNECTIONS; iPlotConnection++ ) {
        var connection = connections[ iPlotConnection ];
        // blank the plot area
        context.beginPath();
        var a = projectPlotToScreen( new Point(0,0), iPlotConnection );
        var b = projectPlotToScreen( new Point(area_width, area_width), iPlotConnection );
        context.rect( a.x, a.y, b.x-a.x, b.y-a.y );
        context.fillStyle = 'white';
        context.fill();
        // label the axes
        var horiz_axis_label_pos = projectPlotToScreen( new Point( area_width/2, 0 ), iPlotConnection );
        var vert_axis_label_pos = projectPlotToScreen( new Point( 0, area_width/2 ), iPlotConnection );
        context.font = "12px Arial";
        context.textAlign = "center";
        if( connection.a == iDrivenVariable ) {
            if( currentMousePositionAccepted )
                context.fillStyle = 'limegreen';
            else
                context.fillStyle = 'red';
        }
        else
            context.fillStyle = "black";
        context.fillText( variables[ connection.a ].label, horiz_axis_label_pos.x, horiz_axis_label_pos.y );
        if( connection.b == iDrivenVariable ) {
            if( currentMousePositionAccepted )
                context.fillStyle = 'limegreen';
            else
                context.fillStyle = 'red';
        }
        else
            context.fillStyle = "black";
        context.fillText( variables[ connection.b ].label, vert_axis_label_pos.x, vert_axis_label_pos.y );
        // draw the current state as a blue dot
        var connection = connections[iPlotConnection];
        var p = new Point( variables[connection.a].value, variables[connection.b].value );
        var pp = projectPlotToScreen( p, iPlotConnection );
        context.beginPath();
        context.arc(pp.x, pp.y, 3, 0, 2*Math.PI);
        context.fillStyle = 'blue';
        context.fill();
        // draw the constraints
        for( var iSegmentGroup = 0; iSegmentGroup < connection.connected_segments.length; iSegmentGroup++) {
            var segment_group = connection.connected_segments[ iSegmentGroup ];
            for( var iSegment = 0; iSegment < segment_group.constraints.length; iSegment++) {
                var constraint = segment_group.constraints[iSegment].segment;
                drawConstraint( constraint, iPlotConnection );
            }
        }
    }
}

// -----------------------------------------------------------------------------------

function drawPart( iPart ) {
    var part = parts[ iPart ];
    
    var poly = getTransformedPart( iPart );
    if( part.variables_that_affect_us.indexOf( iDrivenVariable ) >= 0 ) {
        if( currentMousePositionAccepted )
            context.fillStyle = 'limegreen';
        else
            context.fillStyle = 'red';
    }
    else
        context.fillStyle = 'grey';
    context.beginPath();
    var centroid = new Point(0,0);
    for( var iPt = 0; iPt < poly.length; iPt++ ) {
        var p = projectAreaToScreen( poly[ iPt ] );
        if( iPt == 0 )
            context.moveTo( p.x, p.y );
        else
            context.lineTo( p.x, p.y );
        centroid = add( centroid, p );
    }
    centroid = div( centroid, poly.length );
    context.closePath();
    context.fill();
    context.lineWidth = 1;
    context.strokeStyle = 'black';
    context.stroke();
    
    context.font = "30px Arial";
    context.textAlign = "center";
    context.fillStyle = "black";
    context.textBaseline="middle"; 
    context.fillText( part.label, centroid.x, centroid.y );
}

// -----------------------------------------------------------------------------------

function applyPartTransform( iPart, p ) {
    var part = parts[ iPart ];
    // first apply the rotations
    var cp = rotate( p, part.initial_transform.rotation );
    for( var iiVariable = 0; iiVariable < part.variables_that_affect_us.length; iiVariable++ ) {
        var iVariable = part.variables_that_affect_us[ iiVariable ];
        var variable = variables[ iVariable ];
        cp = rotate( cp, variable.transform.rotation * variable.value );
    }
    // then apply translations
    cp = add( cp, part.initial_transform.translation );
    for( var iiVariable = 0; iiVariable < part.variables_that_affect_us.length; iiVariable++ ) {
        var iVariable = part.variables_that_affect_us[ iiVariable ];
        var variable = variables[ iVariable ];
        cp = add( cp, mul( variable.transform.translation, variable.value ) );
    }
    return cp;
}

// -----------------------------------------------------------------------------------

function applyInversePartTransform( iPart, p ) {
    var part = parts[ iPart ];
    // first apply inverse translations
    var cp = add( p, mul( part.initial_transform.translation, -1 ) );
    for( var iiVariable = 0; iiVariable < part.variables_that_affect_us.length; iiVariable++ ) {
        var iVariable = part.variables_that_affect_us[ iiVariable ];
        var variable = variables[ iVariable ];
        cp = add( cp, mul( variable.transform.translation, -variable.value ) );
    }
    // then apply the inverse rotations
    cp = rotate( cp, -part.initial_transform.rotation );
    for( var iiVariable = 0; iiVariable < part.variables_that_affect_us.length; iiVariable++ ) {
        var iVariable = part.variables_that_affect_us[ iiVariable ];
        var variable = variables[ iVariable ];
        cp = rotate( cp, variable.transform.rotation * -variable.value );
    }
    return cp;
}

// -----------------------------------------------------------------------------------

function applyPartTransformWithChangedVariable( iPart, p, iVar, value ) {
    var part = parts[ iPart ];
    // first apply the rotations
    var cp = rotate( p, part.initial_transform.rotation );
    for( var iiVariable = 0; iiVariable < part.variables_that_affect_us.length; iiVariable++ ) {
        var iVariable = part.variables_that_affect_us[ iiVariable ];
        var variable = variables[ iVariable ];
        var value_to_use = (iVariable==iVar)?value:variable.value;
        cp = rotate( cp, variable.transform.rotation * value_to_use );
    }
    // then apply translations
    cp = add( cp, part.initial_transform.translation );
    for( var iiVariable = 0; iiVariable < part.variables_that_affect_us.length; iiVariable++ ) {
        var iVariable = part.variables_that_affect_us[ iiVariable ];
        var variable = variables[ iVariable ];
        var value_to_use = (iVariable==iVar)?value:variable.value;
        cp = add( cp, mul( variable.transform.translation, value_to_use ) );
    }
    return cp;
}

// -----------------------------------------------------------------------------------

function drawVariableHandle( iVariable, areaPos ) {
    if( iVariable < 0 ) return;
    var variable = variables[ iVariable ];
    
    context.lineWidth = 1;
    context.strokeStyle = 'black';
    
    // show where this point would move to
    var pp = applyInversePartTransform( variable.iPart, areaPos );
    var arrow_length_in_variable_units = ( variable.max_value - variable.min_value ) * 0.05;
    var p1 = applyPartTransformWithChangedVariable( variable.iPart, pp, iVariable, variable.value + arrow_length_in_variable_units );
    var p2 = applyPartTransformWithChangedVariable( variable.iPart, pp, iVariable, variable.value - arrow_length_in_variable_units );
    var sp = projectAreaToScreen( areaPos );
    var sp1 = projectAreaToScreen( p1 );
    var sp2 = projectAreaToScreen( p2 );
    
    drawArrow( sp, sp1 );
    drawArrow( sp, sp2 );
    
    return;
}

// -----------------------------------------------------------------------------------

function drawArrow( from, to ) {
    var headlen = 10; // length of head in pixels
    var angle = Math.atan2(to.y-from.y,to.x-from.x);

    context.beginPath();
    context.moveTo(from.x, from.y);
    context.lineTo(to.x, to.y);
    context.stroke();

    context.beginPath();
    context.moveTo(to.x-headlen*Math.cos(angle-Math.PI/6),to.y-headlen*Math.sin(angle-Math.PI/6));
    context.lineTo(to.x, to.y);
    context.lineTo(to.x-headlen*Math.cos(angle+Math.PI/6),to.y-headlen*Math.sin(angle+Math.PI/6));
    context.stroke();
}

// -----------------------------------------------------------------------------------

function drawConstraint( constraint, iPlotConnection ) {
    var a = projectPlotToScreen( constraint.p1, iPlotConnection );
    var b = projectPlotToScreen( constraint.p2, iPlotConnection );
    drawDirectedLineSegment( a, b );
}
    
// -----------------------------------------------------------------------------------

function drawDirectedLineSegment( a, b ) {
    context.beginPath();
    context.moveTo( a.x, a.y );
    context.lineTo( b.x, b.y );
    context.lineWidth = 1;
    context.strokeStyle = 'black';
    context.stroke();
    var d = 8;
    var n = norm( perp( sub( b, a ) ) );
    var offset = mul( n, d/2 );
    var oa = add( a, offset );
    var ob = add( b, offset );
    context.beginPath();
    context.moveTo( oa.x, oa.y );
    context.lineTo( ob.x, ob.y );
    context.lineWidth = d;
    context.strokeStyle = 'rgba(0,0,0,0.1)';
    context.stroke();
}

// -----------------------------------------------------------------------------------

// return true if we were able to perform the whole move
function tryMoveDriver( grabPos, mousePos ) {
    var variable = variables[ iDrivenVariable ];
    var arrow_length_in_variable_units = ( variable.max_value - variable.min_value ) * 0.05;
    var pp = applyInversePartTransform( variable.iPart, grabPos );
    var p1 = applyPartTransformWithChangedVariable( variable.iPart, pp, iDrivenVariable, variable.value + arrow_length_in_variable_units );
    var p2 = applyPartTransformWithChangedVariable( variable.iPart, pp, iDrivenVariable, variable.value - arrow_length_in_variable_units );
    var new_value = null;
    if( len( sub( mousePos, p1 ) ) < len( sub( mousePos, p2 ) ) ) {
        // move in p1 direction (+ve)
        var a = sub( mousePos, grabPos );
        var b = sub( p1, grabPos );
        new_value = variable.value + dot( a, norm( b ) ) * arrow_length_in_variable_units / len( b );
    }
    else {
        // move in p2 direction (-ve)
        var a = sub( mousePos, grabPos );
        var b = sub( p2, grabPos );
        new_value = variable.value - dot( a, norm( b ) ) * arrow_length_in_variable_units / len( b );
    }

    var moved = new Array( N_VARIABLES );
    for( var i = 0; i < N_VARIABLES; i++ )
        moved[ i ] = false;
    return tryChangeVariable( iDrivenVariable, new_value, moved );
}

// -----------------------------------------------------------------------------------

function tryChangeVariable( iVariable, new_value, moved ) {
    // TODO: take copy of moved values, in order to restore after each recursion call? think only need if 
    //       repeatedly searching for constraints in order to go all the way to new_value
    //while(1) 
    {
        // find the first constraint that intersects this change
        var cr = findFirstConstraintCollision( iVariable, new_value, moved );
        // if none then there's nothing in the way, so we don't need to check any further
        if( cr.outcome == CollisionOutcome.MISS ) {
            variables[ iVariable ].value = new_value;
            console.log('no colliding constraints found');
            return true;
        }
        // if friction jam then we can stop immediately, with no knock-on effects
        if( cr.outcome == CollisionOutcome.FRICTION_JAM ) {
            variables[ iVariable ].value = cr.isA ? cr.firstContact.x : cr.firstContact.y;
            console.log('friction jam');
            return false;
        }
        // else this move has caused a slide (to end of constraint or partial) which
        // drives another variable. So we need to recurse down to check if we can change *that* variable.
        var old_other_value = variables[ cr.iOtherVariable ].value;
        var new_other_value = cr.isA ? cr.slideTo.y : cr.slideTo.x;
        moved[ iVariable ] = true;
        var ok = tryChangeVariable( cr.iOtherVariable, new_other_value, moved );
        if( !ok ) {
            // one of the other parts jammed somewhere along the slide - but where?
            // can we just inspect the other variable to see how far it got?
            //variables[ iVariable ].value += ( new_value - variables[ iVariable ].value ) * ( variables[ cr.iOtherVariable ].value - old_other_value ) / ( new_other_value - old_other_value );
            // or just move this part as far as we know is safe?
            variables[ iVariable ].value = cr.isA ? cr.firstContact.x : cr.firstContact.y;
            // (this is OK for now - might take another little push to make full contact)
            // (or do we need to return something from the tryChangeVariable function somehow?)
            console.log('knock-on constraints');
            return false; 
        }
        variables[ iVariable ].value = cr.isA ? cr.slideTo.x : cr.slideTo.y;
        if( cr.outcome == CollisionOutcome.SLIDE_TO_CORNER_JAM || cr.outcome == CollisionOutcome.SLIDE_TO_FRICTION_JAM ) {
            // we slid on this constraint without subsequent problems but now we can go no further
            console.log('slide to jam');
            return false;
        }
        if( cr.outcome == CollisionOutcome.PARTIAL_SLIDE ) {
            // we slid all the way we wanted and there were no knock-on problems so we're done
            console.log('slid along constraint');
            return true;
        }
        // (else is CollisionOutcome.SLIDE_TO_END)
        // so now we have navigated past the first constraint and we have made some progress towards new_value
        // but we need to try to move further from this location, checking the constraints again
        // (maybe check here that we did make *some* progress, else may loop forever)
        // (or guarantee that we haven't checked each constraint already)
        console.log('slid to end');
        return true; // DEBUG - although maybe is actually better like this for visualisation since it draws the progress so far
                     //         and subsequent mouse moves will take it further. for parts with complex shapes this might get annoying
                     //         since the user would have to wiggle their mouse to persuade the driven part to keep moving through
                     //         multiple constraints.
    }
}

// -----------------------------------------------------------------------------------

function findFirstConstraintCollision( iVariable, new_value, moved ) {
    // Find the first constraint that intersects this change (in any connection that this variable has with a not moved variable)
    var first_collision = { outcome:CollisionOutcome.MISS };
    var closest_dist = Number.MAX_VALUE;
    for( var iConnection = 0; iConnection < N_CONNECTIONS; iConnection++ ) {
        var connection = connections[ iConnection ];
        var move = null;
        var iOtherVariable = null;
        var isA = null;
        if( connection.a == iVariable && !moved[ connection.b ] )
        {
            isA = true;
            iOtherVariable = connection.b;
            move = new LineSegment( new Point( variables[ iVariable ].value, variables[ iOtherVariable ].value ), 
                                    new Point( new_value, variables[ iOtherVariable ].value ) );
        }
        else if( connection.b == iVariable && !moved[ connection.a ] )
        {
            isA = false;
            iOtherVariable = connection.a;
            move = new LineSegment( new Point( variables[ iOtherVariable ].value, variables[ iVariable ].value ), 
                                    new Point( variables[ iOtherVariable ].value, new_value ) );
        }
        else {
            continue;
        }
        for( var iConstraintGroup = 0; iConstraintGroup < connection.connected_segments.length; iConstraintGroup++ ) {
            var constraints = connection.connected_segments[ iConstraintGroup ].constraints;
            for( var iConstraint = 0; iConstraint < constraints.length; iConstraint++ ) {
                var cr = testConstraint( move, constraints, iConstraint );
                if( cr.outcome == CollisionOutcome.MISS ) continue;
                var dist = len( sub( cr.firstContact, move.p1 ) );
                if( dist < closest_dist ) {
                    closest_dist = dist;
                    first_collision = cr;
                    first_collision.iOtherVariable = iOtherVariable;
                    first_collision.isA = isA;
                }
            }
        }
    }
    return first_collision;
}

// -----------------------------------------------------------------------------------

function getMousePos(canvas, evt) {
    var rect = canvas.getBoundingClientRect();
    return {
        x: evt.clientX - rect.left,
        y: evt.clientY - rect.top
    };
}

// -----------------------------------------------------------------------------------

function Point(x,y) {
    this.x = x;
    this.y = y;
}

// -----------------------------------------------------------------------------------

function LineSegment(p1,p2) {
    this.p1 = p1;
    this.p2 = p2;
}

// -----------------------------------------------------------------------------------

function isBehind( point, constraint ) {
    var dp = dot( norm( sub( point, constraint.p1 ) ), norm( perp( sub( constraint.p2, constraint.p1 ) ) ) );
    return dp < -epsilon; // (allow for floating point issues)
}

// -----------------------------------------------------------------------------------

function len( v ) {
    return Math.hypot( v.x, v.y );
}

// -----------------------------------------------------------------------------------

function perp( v ) {
    return new Point( -v.y, v.x );
}

// -----------------------------------------------------------------------------------

function norm( v ) {
    return div( v, len( v ) );
}

// -----------------------------------------------------------------------------------

function add( a, b ) {
    return new Point( a.x + b.x, a.y + b.y );
}

// -----------------------------------------------------------------------------------

function sub( a, b ) {
    return new Point( a.x - b.x, a.y - b.y );
}

// -----------------------------------------------------------------------------------

function mul( a, f ) {
    return new Point( a.x * f, a.y * f );
}

// -----------------------------------------------------------------------------------

function div( a, f ) {
    return new Point( a.x / f, a.y / f );
}

// -----------------------------------------------------------------------------------

function dot( a, b ) {
    return a.x * b.x + a.y * b.y;
}

// -----------------------------------------------------------------------------------

function lerp( a, b, u ) {
    return add( a, mul( sub( b, a ), u ) );
}

// -----------------------------------------------------------------------------------

function pointInRect( p, r ) {
    return p.x >= r.x && p.x <= r.x + r.w && p.y >= r.y && p.y <= r.y + r.h;
}

// -----------------------------------------------------------------------------------

function testConstraint( move, constraints, iConstraint ) {
    var constraint = constraints[iConstraint];
    // a move is a collision if:
    // 1. the move segment intersects the constraint segment
    // 2. the end of the move is behind the constraint segment
    // 3. the start of the move is not behind the constraint segment
    // 4. the resulting slide would leave the start in a different place
    var intersection = lineSegmentsIntersection( move, constraint.segment );
    var endIsBehind = isBehind( move.p2, constraint.segment );
    var startIsBehind = isBehind( move.p1, constraint.segment );
    if( !intersection.test || !endIsBehind || startIsBehind ) {
        // no collision
        return { outcome:CollisionOutcome.MISS };
    }
    var gradient = getGradientForConstraint( move, constraint.segment );
    if( Math.abs( gradient ) < minGradient ) {
        // friction jam
        return { outcome:CollisionOutcome.FRICTION_JAM, firstContact:intersection.point };
    }
    var beforeSegment = new LineSegment( move.p1, intersection.point );
    var slide_intersection = lineSegmentWithLineIntersection( constraint.segment, move.p2, perp( sub( move.p2, move.p1 ) ) );
    if( slide_intersection.test ) {
        // partial slide
        return { outcome:CollisionOutcome.PARTIAL_SLIDE, firstContact:intersection.point, slideTo:slide_intersection.point };
    }
    // if we slid to the end, check that the next segment in the sequence has a favorable gradient
    // else this is a jam position
    var slideEnd = null;
    var neighboring_constraint = null;
    var has_neighbor = false;
    if( gradient < 0 ) {
        slideEnd = constraint.segment.p1;
        if( constraint.connected_to_previous ) {
            has_neighbor = true;
            neighboring_constraint = constraints[ ( iConstraint - 1 + constraints.length ) % constraints.length ];
        }
    }
    else {
        slideEnd = constraint.segment.p2;
        if( constraint.connected_to_next ) {
            has_neighbor = true;
            neighboring_constraint = constraints[ ( iConstraint + 1 ) % constraints.length ];
        }
    }
    var neighboring_gradient = null;
    if( has_neighbor )
        neighboring_gradient = getGradientForConstraint( move, neighboring_constraint.segment );
    if( has_neighbor && Math.abs( neighboring_gradient ) < minGradient ) {
        // slide to friction jam
        return { outcome:CollisionOutcome.SLIDE_TO_FRICTION_JAM, firstContact:intersection.point, slideTo:slideEnd };
    }
    if( !has_neighbor || ( neighboring_gradient < 0 && gradient < 0 ) || ( neighboring_gradient > 0 && gradient > 0 ) ) {
        if( len( sub( slideEnd, move.p1 ) ) < epsilon ) {
            // no collision - would slide to the same place as we started
            return { outcome:CollisionOutcome.MISS };
        }
        // slide to end
        return { outcome:CollisionOutcome.SLIDE_TO_END, firstContact:intersection.point, slideTo:slideEnd };
    }
    // slide to corner jam
    return { outcome:CollisionOutcome.SLIDE_TO_CORNER_JAM, firstContact:intersection.point, slideTo:slideEnd };
}

// -----------------------------------------------------------------------------------

function lineSegmentsIntersection(s1,s2) {
    return lineSegmentsIntersection2(s1.p1.x,s1.p1.y,s1.p2.x,s1.p2.y,s2.p1.x,s2.p1.y,s2.p2.x,s2.p2.y);
}

// -----------------------------------------------------------------------------------

function lineSegmentsIntersection2(a,b,c,d,p,q,r,s) {
    var det = (c - a) * (s - q) - (r - p) * (d - b);
    if (det === 0) {
        return { test:false };
    } else {
        var lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;
        var gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;
        var intersects = (-epsilon <= lambda && lambda <= 1+epsilon) && (-epsilon <= gamma && gamma <= 1+epsilon);
        var p = lerp( new Point(a,b), new Point(c,d), lambda );
        return { test:intersects, point:p };
    }
}

// -----------------------------------------------------------------------------------

function lineSegmentWithLineIntersection( s, p2, v2 ) {
    return lineSegmentWithLineIntersection2( s.p1.x, s.p1.y, s.p2.x, s.p2.y, p2.x, p2.y, p2.x+v2.x, p2.y+v2.y );
}

// -----------------------------------------------------------------------------------

function lineSegmentWithLineIntersection2( a,b,c,d,p,q,r,s ) {
    var det = (c - a) * (s - q) - (r - p) * (d - b);
    if (det === 0) {
        return { test:false };
    } else {
        var lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;
        var gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;
        var intersects = (-epsilon <= lambda && lambda <= 1+epsilon);
        var p = lerp( new Point(a,b), new Point(c,d), lambda );
        return { test:intersects, point:p };
    }
}

// -----------------------------------------------------------------------------------

function lineWithLineIntersection( p1, v1, p2, v2 ) {
    return lineWithLineIntersection2( p1.x, p1.y, p1.x + v1.x, p1.y + v1.y, 
                                      p2.x, p2.y, p2.x + v2.x, p2.y + v2.y );
}

// -----------------------------------------------------------------------------------

function lineWithLineIntersection2( a,b,c,d,p,q,r,s ) {
    var det = (c - a) * (s - q) - (r - p) * (d - b);
    if (det === 0) {
        return { test:false }; // parallel lines
    } else {
        var lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;
        //gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;
        var gamma = ((d - b) * (r - a) + (a - c) * (s - b)) / det; // TODO: are the other gammas wrong?
        return { test:true, u1:lambda, u2:gamma };
    }
}

// -----------------------------------------------------------------------------------

function getGradientForConstraint( move, constraint ) {
    return dot( sub( move.p2, move.p1 ), sub( constraint.p2, constraint.p1 ) );
}

// -----------------------------------------------------------------------------------

function Connection(a,b) {
    this.a = a; // this indexed variable is the x-coordinate
    this.b = b; // this indexed variable is the y-coordinate
    this.connected_segments = [];
}

// -----------------------------------------------------------------------------------

function ConnectedSegmentGroup() {
    this.constraints = [];
}

// -----------------------------------------------------------------------------------

function Constraint(s,cp,cn) {
    this.segment = s;
    this.connected_to_previous = cp;
    this.connected_to_next = cn;
}

// -----------------------------------------------------------------------------------

function pointInPolygon(poly, pt)
{
    var inside = false;
    var i, j;
    for( i = 0, j = poly.length-1; i < poly.length; j = i++) {
        if( ( ( poly[i].y > pt.y ) != ( poly[j].y > pt.y ) ) && 
            ( pt.x < ( poly[j].x - poly[i].x ) * ( pt.y - poly[i].y ) / ( poly[j].y - poly[i].y ) + poly[i].x ) ) 
        {
            inside = !inside;
        }
    }
    return inside;
}

// -----------------------------------------------------------------------------------

function applyTransform( p, transform, amount ) {
    return add( rotate( p, amount*transform.rotation ), mul( transform.translation, amount ) );
}

// -----------------------------------------------------------------------------------

function rotate( p, theta ) {
    return new Point( Math.cos(theta)*p.x - Math.sin(theta)*p.y, 
                      Math.sin(theta)*p.x + Math.cos(theta)*p.y );
}

// -----------------------------------------------------------------------------------

</script>
</body>
</html>
