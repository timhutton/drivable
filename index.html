<!DOCTYPE HTML>
<html>
<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<style>
    body {
        margin: 10px;
        padding: 0px;
    }
</style>
</head>
<body>
<p>Grab a truck to slide it left and right. It turns red if it is blocked.</p>

<p>On the right is a set of truck pairs, showing the constraints that exist between them. We plot with a blue dot the two truck positions as x and y. Click on the plot to change the variables directly.</p>

<p>The whole idea here is that we don't need to do collision detection at runtime since the constraints tell us everything we need to know about the movement. We are exploring the class of systems for which this concept remains useful.</p>
<canvas id="myCanvas" width="1200" height="700"></canvas>
<script>

// -----------------------------------------------------------------------------------

// If the positions of parts are controlled by variables, then a drivable constraint is 
// a line segment in the 2D space of two variables representing a physical contact between 
// two pieces. (Could generalize to curve segments.)
// If your intended step takes you across the constraint segment then it steers you to
// one side or the other. If you meet it at right-angles then you get stuck
// and can go no further. (For parts with more than one way of moving (e.g. sliding cogs)
// a drivable constraint would be a patch of surface but we ignore such cases for now.)

// A tricky question is how to compute these segments for a set of moving parts.
// But if we know the segments then we can use them and let the user move the parts around.
// So for now we manually specify a list of segments.

// Each part has (for now) one variable that controls how it can move. e.g. a truck has a single
// position, a rotating arm has an angle.
// If two parts are capable of directly interacting then they have a connection. A connection is a list
// of drivable constraints.

// -----------------------------------------------------------------------------------

var area_width = 700;
var area_height = 400;
var minGradient = 0.1;
var epsilon = 1E-6; // for floating-point issues
var margin = 20; // pixels

var canvas = document.getElementById('myCanvas');
var context = canvas.getContext('2d');
var iDrivenVariable = -1;
var currentMousePositionAccepted = true;
var grabPos = null;

var N_PARTS = null;
var N_CONNECTIONS = null;
var N_VARIABLES = null;
var parts = null;
var connections = null;
var variables = null;
var plot_scale = null;

var CollisionOutcome = {
    MISS:                  1,
    FRICTION_JAM:          2,
    PARTIAL_SLIDE:         3,
    SLIDE_TO_END:          4,
    SLIDE_TO_FRICTION_JAM: 5,
    SLIDE_TO_CORNER_JAM:   6
};

// -----------------------------------------------------------------------------------

initWithTrucks(5);
draw(canvas);

// -----------------------------------------------------------------------------------

function initWithTrucks( numTrucksWanted ) {
    var truck_width = 60;
    var truck_height = 40;
    var truck_top = 200;
    
    N_VARIABLES = numTrucksWanted;
    N_PARTS = N_VARIABLES; // (for now each part has a single degree of freedom)

    // each part is a polygon, centered at its rotation point
    parts = new Array( N_PARTS );
    for( var iPart = 0; iPart < N_PARTS; iPart++ ) {
        var poly = [ new Point(-truck_width/2,-truck_height/2), new Point(truck_width/2,-truck_height/2),
                     new Point(truck_width/2,truck_height/2),   new Point(-truck_width/2,truck_height/2) ];
        var initial_transform = new Transform( 0, new Point(0,truck_top) );
        var label = String.fromCharCode( 65 + iPart );
        var variables_that_affect_us = [ iPart ];
        parts[iPart] = new Part( label, poly, initial_transform, variables_that_affect_us );
    }

    // each variable applies to a part, and transforms it in some way
    variables = new Array(N_VARIABLES);
    for( var iVariable = 0; iVariable < N_VARIABLES; iVariable++ ) {
        var initial_value = (iVariable+1) * area_width / (N_PARTS+1);
        var transform = new Transform( 0, new Point(1,0) );
        var iPart = iVariable;
        var label = parts[ iPart ].label; // (if this part had more than one variable then would need to disambiguate)
        variables[iVariable] = new Variable( label, initial_value, transform );
    }    

    N_CONNECTIONS = N_PARTS-1;
    plot_scale = ( canvas.height - margin*(N_CONNECTIONS+1) ) / ( area_width * N_CONNECTIONS );

    // stop the trucks passing through each other or the wall
    connections = new Array(N_CONNECTIONS);
    for( var i = 0; i < N_CONNECTIONS; i++ ) {
        connections[i] = new Connection(i,i+1); 
        var group = new ConnectedSegmentGroup(); // within a group, constraints join onto each other in sequence
        if( N_CONNECTIONS == 1 ) {
            var leftWall = new Constraint( new LineSegment( new Point( truck_width/2, area_width - truck_width/2 ),
                                                            new Point( truck_width/2, truck_width + truck_width/2 ) ),
                                           true,
                                           true );
            group.constraints.push( leftWall );
            var trucksPush = new Constraint( new LineSegment( new Point( truck_width/2, truck_width + truck_width/2 ),
                                                              new Point( area_width - truck_width*3/2, area_width - truck_width/2) ),
                                             true,
                                             true );
            group.constraints.push( trucksPush );
            var rightWall = new Constraint( new LineSegment( new Point( area_width - truck_width*3/2, area_width-truck_width/2 ),
                                                             new Point( truck_width/2, area_width-truck_width/2 ) ),
                                            true,
                                            true );
            group.constraints.push( rightWall );
        }
        else if( i == 0 ) {
            var leftWall = new Constraint( new LineSegment( new Point( truck_width/2, area_width - truck_width/2 ),
                                                            new Point( truck_width/2, truck_width + truck_width/2 ) ),
                                           false,
                                           true );
            group.constraints.push( leftWall );
            var trucksPush = new Constraint( new LineSegment( new Point( truck_width/2, truck_width + truck_width/2 ),
                                                              new Point( area_width - truck_width*3/2, area_width - truck_width/2) ),
                                             true,
                                             false );
            group.constraints.push( trucksPush );
        }
        else if( i == N_CONNECTIONS-1 ) {
            var trucksPush = new Constraint( new LineSegment( new Point( truck_width/2, truck_width + truck_width/2 ),
                                                              new Point( area_width - truck_width*3/2, area_width - truck_width/2 ) ),
                                             false,
                                             true );
            group.constraints.push( trucksPush );
            var rightWall = new Constraint( new LineSegment( new Point( area_width - truck_width*3/2, area_width-truck_width/2 ),
                                                             new Point( truck_width/2, area_width-truck_width/2 ) ),
                                            true,
                                            false );
            group.constraints.push( rightWall );
        }
        else {
            var trucksPush = new Constraint( new LineSegment( new Point(truck_width/2,truck_width+truck_width/2),
                                                              new Point(area_width-truck_width*3/2,area_width-truck_width/2) ),
                                             false,
                                             false );
            group.constraints.push( trucksPush );
        }
        connections[i].connected_segments.push( group );
    }
}
    
// -----------------------------------------------------------------------------------

function Part( label, poly, transform, variables_that_affect_us ) {
    this.label = label;
    this.poly = poly;
    this.transform = transform;
    this.variables_that_affect_us = variables_that_affect_us;
 }
 
// -----------------------------------------------------------------------------------

function Transform( rotation, translation ) {
    this.rotation = rotation;
    this.translation = translation;
 }
 
// -----------------------------------------------------------------------------------

function Variable( label, initial_value, transform ) {
    this.label = label;
    this.value = initial_value;
    this.transform = transform;
}

// -----------------------------------------------------------------------------------

canvas.addEventListener('mousedown', function(evt) {
    var mousePos = getMousePos(canvas, evt);
    // if within a shape then make it the driver
    var areaPos = projectScreenToArea( mousePos );
    for( var iPart = 0; iPart < N_PARTS; iPart++ ) {
        if( pointInPolygon( getTransformedPart( iPart ), areaPos ) ) {
            iDrivenVariable = parts[ iPart ].variables_that_affect_us[0]; // TODO: how can the user select other variables to drive?
            grabPos = areaPos;
            draw(canvas);
            return;
        }
    }
    // if on a plot then set those variables directly
    for( var iPlotConnection = 0; iPlotConnection < N_CONNECTIONS; iPlotConnection++ ) {
        var plotPos = projectScreenToPlot( mousePos, iPlotConnection );
        if( pointInRect( plotPos, {x:0,y:0,w:area_width,h:area_width} ) )
        {
            var connection = connections[ iPlotConnection ];
            variables[ connection.a ].value = plotPos.x;
            variables[ connection.b ].value = plotPos.y;
            draw(canvas);
            return;
        }
    }
}, false);

// -----------------------------------------------------------------------------------

canvas.addEventListener('mousemove', function(evt) {
    if( iDrivenVariable < 0 ) return;
    var mousePos = getMousePos(canvas, evt);
    var areaPos = projectScreenToArea( mousePos );
    currentMousePositionAccepted = tryMoveDriver( grabPos, areaPos );
    if( currentMousePositionAccepted ) {
        grabPos = areaPos;
        // TODO: this is not quite right - the truck might have moved a little even if was blocked from going the whole way
        //       result is slight cursor drift from the attachment point
    }
    draw(canvas);
}, false);

// -----------------------------------------------------------------------------------

canvas.addEventListener('mouseup', function(evt) {
    iDrivenVariable = -1;
    draw(canvas);
}, false);

// -----------------------------------------------------------------------------------

function getTransformedPart( iPart ) {
    var tp = [];
    var part = parts[ iPart ];
    for( var iPt = 0; iPt < parts[iPart].poly.length; iPt++ ) {
        var p = applyTransform( part.poly[iPt], part.transform, 1 );
        for( var iiVariable = 0; iiVariable < part.variables_that_affect_us.length; iiVariable++ ) {
            var iVariable = part.variables_that_affect_us[ iiVariable ];
            var variable = variables[ iVariable ];
            p = applyTransform( p, variable.transform, variable.value );
        }
        tp.push( p );
    }
    return tp;
}

// -----------------------------------------------------------------------------------

function projectAreaToScreen( p ) {
    return new Point(p.x+margin, p.y+margin );
}

// -----------------------------------------------------------------------------------

function projectScreenToArea( p ) {
    return new Point(p.x-margin, p.y-margin );
}

// -----------------------------------------------------------------------------------

function projectPlotToScreen( p, i ) {
    return new Point( p.x*plot_scale + area_width+margin*2, 
                      (area_width*plot_scale+margin)*i + margin + (area_width-p.y)*plot_scale  );
}

// -----------------------------------------------------------------------------------

function projectScreenToPlot( p, i ) {
    return new Point( ( p.x - (area_width+margin*2) ) / plot_scale, 
                      area_width - (p.y - (area_width*plot_scale+margin)*i - margin ) / plot_scale );
}

// -----------------------------------------------------------------------------------

function draw(canvas) {
    var context = canvas.getContext('2d');

    // show the limit of the canvas itself
    context.beginPath();
    context.rect(0, 0, canvas.width, canvas.height);
    context.fillStyle = '#F0F0F0';
    context.fill();
    
    // show the collision area
    context.beginPath();
    var a = projectAreaToScreen( new Point(0,0) );
    var b = projectAreaToScreen( new Point(area_width,area_height) );
    context.rect( a.x, a.y, b.x-a.x, b.y-a.y );
    context.fillStyle = 'white';
    context.fill();
    context.lineWidth = 1;
    context.strokeStyle = 'black';
    context.stroke();
    
    // draw each part
    for( var i = 0; i < N_VARIABLES; i++ ) {
        drawPart( i );
    }
    
    // plot
    for( var iPlotConnection = 0; iPlotConnection < N_CONNECTIONS; iPlotConnection++ ) {
        var connection = connections[ iPlotConnection ];
        // blank the plot area
        context.beginPath();
        var a = projectPlotToScreen( new Point(0,0), iPlotConnection );
        var b = projectPlotToScreen( new Point(area_width, area_width), iPlotConnection );
        context.rect( a.x, a.y, b.x-a.x, b.y-a.y );
        context.fillStyle = 'white';
        context.fill();
        // label the axes
        var horiz_axis_label_pos = projectPlotToScreen( new Point( area_width/2, 0 ), iPlotConnection );
        var vert_axis_label_pos = projectPlotToScreen( new Point( 0, area_width/2 ), iPlotConnection );
        context.font = "12px Arial";
        context.textAlign = "center";
        if( connection.a == iDrivenVariable ) {
            if( currentMousePositionAccepted )
                context.fillStyle = 'limegreen';
            else
                context.fillStyle = 'red';
        }
        else
            context.fillStyle = "black";
        context.fillText( variables[ connection.a ].label, horiz_axis_label_pos.x, horiz_axis_label_pos.y );
        if( connection.b == iDrivenVariable ) {
            if( currentMousePositionAccepted )
                context.fillStyle = 'limegreen';
            else
                context.fillStyle = 'red';
        }
        else
            context.fillStyle = "black";
        context.fillText( variables[ connection.b ].label, vert_axis_label_pos.x, vert_axis_label_pos.y );
        // draw the current state as a blue dot
        var connection = connections[iPlotConnection];
        var p = new Point( variables[connection.a].value, variables[connection.b].value );
        var pp = projectPlotToScreen( p, iPlotConnection );
        context.beginPath();
        context.arc(pp.x, pp.y, 3, 0, 2*Math.PI);
        context.fillStyle = 'blue';
        context.fill();
        // draw the constraints
        for( var iSegmentGroup = 0; iSegmentGroup < connection.connected_segments.length; iSegmentGroup++) {
            var segment_group = connection.connected_segments[ iSegmentGroup ];
            for( var iSegment = 0; iSegment < segment_group.constraints.length; iSegment++) {
                var constraint = segment_group.constraints[iSegment].segment;
                drawConstraint( constraint, iPlotConnection );
            }
        }
    }
}

// -----------------------------------------------------------------------------------

function drawPart( iPart ) {
    var part = parts[ iPart ];
    
    var poly = getTransformedPart( iPart );
    if( part.variables_that_affect_us.indexOf( iDrivenVariable ) >= 0 ) {
        if( currentMousePositionAccepted )
            context.fillStyle = 'limegreen';
        else
            context.fillStyle = 'red';
    }
    else
        context.fillStyle = 'grey';
    context.beginPath();
    for( var iPt = 0; iPt < poly.length; iPt++ ) {
        var p = projectAreaToScreen( poly[ iPt ] );
        if( iPt == 0)
            context.moveTo( p.x, p.y );
        else
            context.lineTo( p.x, p.y );
    }
    context.closePath();
    context.fill();
    context.lineWidth = 1;
    context.strokeStyle = 'black';
    context.stroke();
    
    context.font = "30px Arial";
    context.textAlign = "center";
    context.fillStyle = "black";
    context.textBaseline="middle"; 
    var cp = applyTransform( new Point( 0, 0 ), part.transform, 1 );
    for( var iiVariable = 0; iiVariable < part.variables_that_affect_us.length; iiVariable++ ) {
        var iVariable = part.variables_that_affect_us[ iiVariable ];
        var variable = variables[ iVariable ];
        cp = applyTransform( cp, variable.transform, variable.value );
    }
    var scp = projectAreaToScreen( cp );
    context.fillText( part.label, scp.x, scp.y );
}

// -----------------------------------------------------------------------------------

function drawConstraint( constraint, iPlotConnection ) {
    var a = projectPlotToScreen( constraint.p1, iPlotConnection );
    var b = projectPlotToScreen( constraint.p2, iPlotConnection );
    context.beginPath();
    context.moveTo( a.x, a.y );
    context.lineTo( b.x, b.y );
    context.lineWidth = 1;
    context.strokeStyle = 'black';
    context.stroke();
    var d = 8;
    var n = norm( perp( sub( b, a ) ) );
    var offset = mul( n, d/2 );
    var oa = add( a, offset );
    var ob = add( b, offset );
    context.beginPath();
    context.moveTo( oa.x, oa.y );
    context.lineTo( ob.x, ob.y );
    context.lineWidth = d;
    context.strokeStyle = 'rgba(0,0,0,0.1)';
    context.stroke();
}

// -----------------------------------------------------------------------------------

// return true if we were able to perform the whole move
function tryMoveDriver( grabPos, mousePos ) {
    var new_value = variables[ iDrivenVariable ].value + mousePos.x - grabPos.x; // TODO: generalize to the variable's transform
    var moved = new Array( N_VARIABLES );
    for( var i = 0; i < N_VARIABLES; i++ )
        moved[ i ] = false;
    return tryChangeVariable( iDrivenVariable, new_value, moved );
}

// -----------------------------------------------------------------------------------

function tryChangeVariable( iVariable, new_value, moved ) {
    // TODO: take copy of moved values, in order to restore after each recursion call? think only need if 
    //       repeatedly searching for constraints in order to go all the way to new_value
    //while(1) 
    {
        // find the first constraint that intersects this change
        var cr = findFirstConstraintCollision( iVariable, new_value, moved );
        // if none then there's nothing in the way, so we don't need to check any further
        if( cr.outcome == CollisionOutcome.MISS ) {
            variables[ iVariable ].value = new_value;
            return true;
        }
        // if friction jam then we can stop immediately, with no knock-on effects
        if( cr.outcome == CollisionOutcome.FRICTION_JAM ) {
            variables[ iVariable ].value = cr.isA ? cr.firstContact.x : cr.firstContact.y;
            return false;
        }
        // else this move has caused a slide (to end of constraint or partial) which
        // drives another variable. So we need to recurse down to check if we can change *that* variable.
        var old_other_value = variables[ cr.iOtherVariable ].value;
        var new_other_value = cr.isA ? cr.slideTo.y : cr.slideTo.x;
        moved[ iVariable ] = true;
        var ok = tryChangeVariable( cr.iOtherVariable, new_other_value, moved );
        if( !ok ) {
            // one of the other parts jammed somewhere along the slide - but where?
            // can we just inspect the other variable to see how far it got?
            //variables[ iVariable ].value += ( new_value - variables[ iVariable ].value ) * ( variables[ cr.iOtherVariable ].value - old_other_value ) / ( new_other_value - old_other_value );
            // or just move this part as far as we know is safe?
            variables[ iVariable ].value = cr.isA ? cr.firstContact.x : cr.firstContact.y;
            // (this is OK for now - might take another little push to make full contact)
            // (or do we need to return something from the tryChangeVariable function somehow?)
            return false; 
        }
        variables[ iVariable ].value = cr.isA ? cr.slideTo.x : cr.slideTo.y;
        if( cr.outcome == CollisionOutcome.SLIDE_TO_CORNER_JAM || cr.outcome == CollisionOutcome.SLIDE_TO_FRICTION_JAM ) {
            // we slid on this constraint without subsequent problems but now we can go no further
            return false;
        }
        if( cr.outcome == CollisionOutcome.PARTIAL_SLIDE ) {
            // we slid all the way we wanted and there were no knock-on problems so we're done
            return true;
        }
        // (else is CollisionOutcome.SLIDE_TO_END)
        // so now we have navigated past the first constraint and we have made some progress towards new_value
        // but we need to try to move further from this location, checking the constraints again
        // (maybe check here that we did make *some* progress, else may loop forever)
        // (or guarantee that we haven't checked each constraint already)
        return true; // DEBUG - although maybe is actually better like this for visualisation since it draws the progress so far
                     //         and subsequent mouse moves will take it further. for parts with complex shapes this might get annoying
                     //         since the user would have to wiggle their mouse to persuade the driven part to keep moving through
                     //         multiple constraints.
    }
}

// -----------------------------------------------------------------------------------

function findFirstConstraintCollision( iVariable, new_value, moved ) {
    // Find the first constraint that intersects this change (in any connection that this variable has with a not moved variable)
    var first_collision = { outcome:CollisionOutcome.MISS };
    var closest_dist = Number.MAX_VALUE;
    for( var iConnection = 0; iConnection < N_CONNECTIONS; iConnection++ ) {
        var connection = connections[ iConnection ];
        var move = null;
        var iOtherVariable = null;
        var isA = null;
        if( connection.a == iVariable && !moved[ connection.b ] )
        {
            isA = true;
            iOtherVariable = connection.b;
            move = new LineSegment( new Point( variables[ iVariable ].value, variables[ iOtherVariable ].value ), new Point( new_value, variables[ iOtherVariable ].value ) );
        }
        else if( connection.b == iVariable && !moved[ connection.a ] )
        {
            isA = false;
            iOtherVariable = connection.a;
            move = new LineSegment( new Point( variables[ iOtherVariable ].value, variables[ iVariable ].value ), new Point( variables[ iOtherVariable ].value, new_value ) );
        }
        else {
            continue;
        }
        for( var iConstraintGroup = 0; iConstraintGroup < connection.connected_segments.length; iConstraintGroup++ ) {
            var constraints = connection.connected_segments[ iConstraintGroup ].constraints;
            for( var iConstraint = 0; iConstraint < constraints.length; iConstraint++ ) {
                var cr = testConstraint( move, constraints, iConstraint );
                if( cr.outcome == CollisionOutcome.MISS ) continue;
                var dist = len( sub( cr.firstContact, move.p1 ) );
                if( dist < closest_dist ) {
                    closest_dist = dist;
                    first_collision = cr;
                    first_collision.iOtherVariable = iOtherVariable;
                    first_collision.isA = isA;
                }
            }
        }
    }
    return first_collision;
}

// -----------------------------------------------------------------------------------

function getMousePos(canvas, evt) {
    var rect = canvas.getBoundingClientRect();
    return {
        x: evt.clientX - rect.left,
        y: evt.clientY - rect.top
    };
}

// -----------------------------------------------------------------------------------

function Point(x,y) {
    this.x = x;
    this.y = y;
}

// -----------------------------------------------------------------------------------

function LineSegment(p1,p2) {
    this.p1 = p1;
    this.p2 = p2;
}

// -----------------------------------------------------------------------------------

function isBehind( point, constraint ) {
    var dp = dot( norm( sub( point, constraint.p1 ) ), norm( perp( sub( constraint.p2, constraint.p1 ) ) ) );
    return dp < -epsilon; // (allow for floating point issues)
}

// -----------------------------------------------------------------------------------

function len( v ) {
    return Math.hypot( v.x, v.y );
}

// -----------------------------------------------------------------------------------

function perp( v ) {
    return new Point( -v.y, v.x );
}

// -----------------------------------------------------------------------------------

function norm( v ) {
    return div( v, len( v ) );
}

// -----------------------------------------------------------------------------------

function add( a, b ) {
    return new Point( a.x + b.x, a.y + b.y );
}

// -----------------------------------------------------------------------------------

function sub( a, b ) {
    return new Point( a.x - b.x, a.y - b.y );
}

// -----------------------------------------------------------------------------------

function mul( a, f ) {
    return new Point( a.x * f, a.y * f );
}

// -----------------------------------------------------------------------------------

function div( a, f ) {
    return new Point( a.x / f, a.y / f );
}

// -----------------------------------------------------------------------------------

function dot( a, b ) {
    return a.x * b.x + a.y * b.y;
}

// -----------------------------------------------------------------------------------

function lerp( a, b, u ) {
    return add( a, mul( sub( b, a ), u ) );
}

// -----------------------------------------------------------------------------------

function pointInRect( p, r ) {
    return p.x >= r.x && p.x <= r.x + r.w && p.y >= r.y && p.y <= r.y + r.h;
}

// -----------------------------------------------------------------------------------

function testConstraint( move, constraints, iConstraint ) {
    var constraint = constraints[iConstraint];
    // a move is a collision if:
    // 1. the move segment intersects the constraint segment
    // 2. the end of the move is behind the constraint segment
    // 3. the start of the move is not behind the constraint segment
    // 4. the resulting slide would leave the start in a different place
    var intersection = lineSegmentsIntersection( move, constraint.segment );
    var endIsBehind = isBehind( move.p2, constraint.segment );
    var startIsBehind = isBehind( move.p1, constraint.segment );
    if( !intersection.test || !endIsBehind || startIsBehind ) {
        // no collision
        return { outcome:CollisionOutcome.MISS };
    }
    var gradient = getGradientForConstraint( move, constraint.segment );
    if( Math.abs( gradient ) < minGradient ) {
        // friction jam
        return { outcome:CollisionOutcome.FRICTION_JAM, firstContact:intersection.point };
    }
    var beforeSegment = new LineSegment( move.p1, intersection.point );
    var slide_intersection = lineSegmentWithLineIntersection( constraint.segment, move.p2, perp( sub( move.p2, move.p1 ) ) );
    if( slide_intersection.test ) {
        // partial slide
        return { outcome:CollisionOutcome.PARTIAL_SLIDE, firstContact:intersection.point, slideTo:slide_intersection.point };
    }
    // if we slid to the end, check that the next segment in the sequence has a favorable gradient
    // else this is a jam position
    var slideEnd = null;
    var neighboring_constraint = null;
    var has_neighbor = false;
    if( gradient < 0 ) {
        slideEnd = constraint.segment.p1;
        if( constraint.connected_to_previous ) {
            has_neighbor = true;
            neighboring_constraint = constraints[ ( iConstraint - 1 + constraints.length ) % constraints.length ];
        }
    }
    else {
        slideEnd = constraint.segment.p2;
        if( constraint.connected_to_next ) {
            has_neighbor = true;
            neighboring_constraint = constraints[ ( iConstraint + 1 ) % constraints.length ];
        }
    }
    var neighboring_gradient = null;
    if( has_neighbor )
        neighboring_gradient = getGradientForConstraint( move, neighboring_constraint.segment );
    if( has_neighbor && Math.abs( neighboring_gradient ) < minGradient ) {
        // slide to friction jam
        return { outcome:CollisionOutcome.SLIDE_TO_FRICTION_JAM, firstContact:intersection.point, slideTo:slideEnd };
    }
    if( !has_neighbor || ( neighboring_gradient < 0 && gradient < 0 ) || ( neighboring_gradient > 0 && gradient > 0 ) ) {
        if( len( sub( slideEnd, move.p1 ) ) < epsilon ) {
            // no collision - would slide to the same place as we started
            return { outcome:CollisionOutcome.MISS };
        }
        // slide to end
        return { outcome:CollisionOutcome.SLIDE_TO_END, firstContact:intersection.point, slideTo:slideEnd };
    }
    // slide to corner jam
    return { outcome:CollisionOutcome.SLIDE_TO_CORNER_JAM, firstContact:intersection.point, slideTo:slideEnd };
}

// -----------------------------------------------------------------------------------

function lineSegmentsIntersection(s1,s2) {
    return lineSegmentsIntersection2(s1.p1.x,s1.p1.y,s1.p2.x,s1.p2.y,s2.p1.x,s2.p1.y,s2.p2.x,s2.p2.y);
}

// -----------------------------------------------------------------------------------

function lineSegmentsIntersection2(a,b,c,d,p,q,r,s) {
  var det, gamma, lambda;
  det = (c - a) * (s - q) - (r - p) * (d - b);
  if (det === 0) {
    return { test:false };
  } else {
    lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;
    gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;
    var intersects = (-epsilon <= lambda && lambda <= 1+epsilon) && (-epsilon <= gamma && gamma <= 1+epsilon);
    var p = lerp( new Point(a,b), new Point(c,d), lambda );
    return { test:intersects, point:p };
  }
}

// -----------------------------------------------------------------------------------

function lineSegmentWithLineIntersection( s, p2, v2 ) {
    return lineSegmentWithLineIntersection2( s.p1.x, s.p1.y, s.p2.x, s.p2.y, p2.x, p2.y, p2.x+v2.x, p2.y+v2.y );
}

// -----------------------------------------------------------------------------------

function lineSegmentWithLineIntersection2( a,b,c,d,p,q,r,s ) {
  var det, gamma, lambda;
  det = (c - a) * (s - q) - (r - p) * (d - b);
  if (det === 0) {
    return { test:false };
  } else {
    lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;
    gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;
    var intersects = (-epsilon <= lambda && lambda <= 1+epsilon);
    var p = lerp( new Point(a,b), new Point(c,d), lambda );
    return { test:intersects, point:p };
  }
}

// -----------------------------------------------------------------------------------

function getGradientForConstraint( move, constraint ) {
    return dot( sub( move.p2, move.p1 ), sub( constraint.p2, constraint.p1 ) );
}

// -----------------------------------------------------------------------------------

function Connection(a,b) {
    this.a = a; // this indexed variable is the x-coordinate
    this.b = b; // this indexed variable is the y-coordinate
    this.connected_segments = [];
}

// -----------------------------------------------------------------------------------

function ConnectedSegmentGroup() {
    this.constraints = [];
}

// -----------------------------------------------------------------------------------

function Constraint(s,cp,cn) {
    this.segment = s;
    this.connected_to_previous = cp;
    this.connected_to_next = cn;
}

// -----------------------------------------------------------------------------------

function pointInPolygon(poly, pt)
{
    var inside = false;
    var i, j;
    for( i = 0, j = poly.length-1; i < poly.length; j = i++) {
        if( ( ( poly[i].y > pt.y ) != ( poly[j].y > pt.y ) ) && 
            ( pt.x < ( poly[j].x - poly[i].x ) * ( pt.y - poly[i].y ) / ( poly[j].y - poly[i].y ) + poly[i].x ) ) 
        {
            inside = !inside;
        }
    }
    return inside;
}

// -----------------------------------------------------------------------------------

function applyTransform( p, transform, amount ) {
    return add( rotate( p, amount*transform.rotation ), mul( transform.translation, amount ) );
}

// -----------------------------------------------------------------------------------

function rotate( p, theta ) {
    return new Point( Math.cos(theta)*p.x - Math.sin(theta)*p.y, 
                      Math.sin(theta)*p.x + Math.cos(theta)*p.y );
}

// -----------------------------------------------------------------------------------

</script>
</body>
</html>
