<!DOCTYPE HTML>
<html>
<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<style>
    body {
        margin: 10px;
        padding: 0px;
    }
</style>
</head>
<body>
<p>Grab an object to slide it on its rail. It turns red if it is blocked.</p>

<p>On the right is a plot showing the constraints that exist between the objects. We plot with a blue dot the two object positions as x and y. Click on the plot to change the variables directly.</p>

<p>The whole idea here is that we don't need to do collision detection at runtime since the constraints tell us everything we need to know about the movement. We are exploring the class of systems for which this concept remains useful.</p>
<canvas id="myCanvas" width="1200" height="700"></canvas>
<script>

// -----------------------------------------------------------------------------------

// If the positions of parts are controlled by variables, then a drivable constraint is 
// a line segment in the 2D space of two variables representing a physical contact between 
// two pieces. (Could generalize to curve segments.)
// If your intended step takes you across the constraint segment then it steers you to
// one side or the other. If you meet it at right-angles then you get stuck
// and can go no further. (For parts with more than one way of moving (e.g. sliding cogs)
// a drivable constraint would be a patch of surface but we ignore such cases for now.)

// A tricky question is how to compute these segments for a set of moving parts.
// But if we know the segments then we can use them and let the user move the parts around.
// So for now we manually specify a list of segments.

// Each part has (for now) one variable that controls how it can move. e.g. a truck has a single
// position, a rotating arm has an angle.
// If two parts are capable of directly interacting then they have a connection. A connection is a list
// of drivable constraints.

// -----------------------------------------------------------------------------------

var area_width = 700;
var area_height = 400;
var minGradient = 0.1;
var epsilon = 1E-6; // for floating-point issues
var margin = 20; // pixels

var canvas = document.getElementById('myCanvas');
var context = canvas.getContext('2d');
var iDrivenVariable = -1;
var currentMousePositionAccepted = true;
var grabPos = null;
var isDragging = false;

var iHighlightedConnection = -1;
var iHighlightedConstraint = -1;

var N_PARTS = null;
var N_CONNECTIONS = null;
var N_VARIABLES = null;
var parts = null;
var connections = null;
var variables = null;

var CollisionOutcome = {
    MISS:                  1,
    FRICTION_JAM:          2,
    SLIDE:                 3,
    NOT_REACHED_YET:       4,
    ALREADY_AT_END:        5,
    CORNER_JAM:            6
};

// ====================================================================================

initWithTrucks(5);
//initWithTestParts();
//initWithTest();
draw(canvas);

// ====================================================================================

function Part( label, poly, initial_transform, variables_that_affect_us ) {
    this.label = label;
    this.poly = poly;
    this.initial_transform = initial_transform;
    this.variables_that_affect_us = variables_that_affect_us;
 }
 
// -----------------------------------------------------------------------------------

function Transform( rotation, translation ) {
    this.rotation = rotation;
    this.translation = translation;
 }
 
// -----------------------------------------------------------------------------------

function Variable( label, iPart, initial_value, transform, min_value, max_value ) {
    this.label = label;
    this.iPart = iPart;
    this.value = initial_value;
    this.transform = transform;
    this.min_value = min_value;
    this.max_value = max_value;
}

// -----------------------------------------------------------------------------------

function Connection(a,b) {
    this.a = a; // this indexed variable is the x-coordinate
    this.b = b; // this indexed variable is the y-coordinate
    this.constraints = [];
}

// -----------------------------------------------------------------------------------

function Constraint( seg, iPart1, iPt1, iPart2, iSeg2 ) {
    this.segment = seg;
    this.iPart1 = iPart1;
    this.iPt1 = iPt1;
    this.iPart2 = iPart2;
    this.iSeg2 = iSeg2;
}

// -----------------------------------------------------------------------------------

function Point(x,y) {
    this.x = x;
    this.y = y;
}

// -----------------------------------------------------------------------------------

function LineSegment(p1,p2) {
    this.p1 = p1;
    this.p2 = p2;
}

// ====================================================================================

function initWithTestParts() {
    N_VARIABLES = 2;
    N_PARTS = 2;
    var N = 20;
    
    parts = new Array( N_PARTS );
    {
        var poly = [ new Point( 200, 200 ), new Point( 150, 150 ), new Point( 200, 150 )/*, new Point( 190, 170 )*/ ];
        /*var poly = new Array(N);
        for( var i = 0; i < N; i++ ) {
            var theta = i*2*Math.PI/N;
            poly[i] = new Point( 100 + 50*Math.cos( theta ), 100 + 50*Math.sin( theta ) );
        }*/
        var initial_transform = new Transform(-0.4,new Point(0,150));
        var label = "A";
        var variables_that_affect_us = [ 0 ];
        parts[0] = new Part( label, poly, initial_transform, variables_that_affect_us );
    }
    {
        //var poly = [ new Point( 300, 300 ), new Point( 350, 300 ), new Point( 350, 350 ) ];
        var poly = new Array(N);
        for( var i = 0; i < N; i++ ) {
            var theta = i*2*Math.PI/N;
            poly[i] = new Point( 300 + 25*Math.cos( theta ), 300 + 60*Math.sin( theta ) );
        }
        var initial_transform = new Transform(0.2,new Point(0,-200));
        var label = "B";
        var variables_that_affect_us = [ 1 ];
        parts[1] = new Part( label, poly, initial_transform, variables_that_affect_us );
    }
    /*{
        var poly = [ new Point( 300, 300 ), new Point( 350, 300 ), new Point( 350, 350 ) ];
        var initial_transform = new Transform(-0.2,new Point(300,-25));
        var label = "C";
        var variables_that_affect_us = [ 2 ];
        parts[2] = new Part( label, poly, initial_transform, variables_that_affect_us );
    }*/
    addTinyNoiseToPartCoordinates();
    
    // each variable applies to a part, and transforms it in some way
    variables = new Array(N_VARIABLES);
    {
        var initial_value = 0;
        var transform = new Transform( 0, new Point(1,0.001) );
        var iPart = 0;
        var label = parts[ iPart ].label; // (if this part had more than one variable then would need to disambiguate)
        var min_value = 0;
        var max_value = 1000;
        variables[0] = new Variable( label, iPart, initial_value, transform, min_value, max_value );
    }    
    {
        var initial_value = 0;
        var transform = new Transform( 0, new Point(0.8,1) );
        var iPart = 1;
        var label = parts[ iPart ].label; // (if this part had more than one variable then would need to disambiguate)
        var min_value = 0;
        var max_value = 1000;
        variables[1] = new Variable( label, iPart, initial_value, transform, min_value, max_value );
    }    
    /*{
        var initial_value = -50;
        var transform = new Transform( 0, new Point(1,1) );
        var iPart = 2;
        var label = parts[ iPart ].label; // (if this part had more than one variable then would need to disambiguate)
        var min_value = 0;
        var max_value = 1000;
        variables[2] = new Variable( label, iPart, initial_value, transform, min_value, max_value );
    }*/

    N_CONNECTIONS = 1;

    connections = new Array(N_CONNECTIONS);
    connections[0] = computeConstraints( 0, 1 );
    //connections[1] = computeConstraints( 1, 2 );
    //connections[2] = computeConstraints( 2, 0 );
}

// -----------------------------------------------------------------------------------

function addTinyNoiseToPartCoordinates() {
    // if have constructed parts with implausibly parallel sides then would get ambiguities in the constraints,
    // so add a tiny bit of noise to make things more sensible
    var r = 0.0001;
    for( var iPart = 0; iPart < N_PARTS; iPart++ ) {
        for( var iPt = 0; iPt < parts[ iPart ].poly.length; iPt++ ) {
            parts[ iPart ].poly[ iPt ] = add( parts[ iPart ].poly[ iPt ], new Point( Math.random()*2*r - r, Math.random()*2*r - r ) );
        }
    }
}

// -----------------------------------------------------------------------------------

function computeConstraints( iVar1, iVar2 ) {

    // ensure that the constraints are facing the right way
    if( iVar2 > iVar1 ) {
        var temp = iVar1;
        iVar1 = iVar2;
        iVar2 = temp;
    }
    
    var connection = new Connection( iVar1, iVar2 );
    var var1 = variables[ iVar1 ];
    var var2 = variables[ iVar2 ];
    var part1 = parts[ var1.iPart ];
    var part2 = parts[ var2.iPart ];
    var poly1 = new Array( part1.poly.length );
    for( var i = 0; i < part1.poly.length; i++ ) {
        poly1[i] = applyTransform( part1.poly[i], part1.initial_transform, 1 );
    }
    var poly2 = new Array( part2.poly.length );
    for( var i = 0; i < part2.poly.length; i++ ) {
        poly2[i] = applyTransform( part2.poly[i], part2.initial_transform, 1 );
    }
    // (TODO: move this into a function
    var v1 = var1.transform.translation; // TODO: rotations
    var v2 = var2.transform.translation; // TODO: rotations
    
    // collisions between objects: make constraints from each (line segment, point) pair
    for( var iPt1 = 0; iPt1 < poly1.length; iPt1++ ) {
        var p1 = poly1[ iPt1 ];
        var seg1L = new LineSegment( poly1[ (iPt1+poly1.length-1)%poly1.length ], p1 );
        var seg1R = new LineSegment( p1, poly1[ (iPt1+1)%poly1.length ] );
        var seg1LN = norm( perp( sub( seg1L.p2, seg1L.p1 ) ) );
        var seg1RN = norm( perp( sub( seg1R.p2, seg1R.p1 ) ) );
        var p1N = norm( add( seg1LN, seg1RN ) );
        for( var iPt2 = 0; iPt2 < poly2.length; iPt2++ ) {
            var p2 = poly2[ iPt2 ];
            var seg2L = new LineSegment( poly2[ (iPt2+poly2.length-1)%poly2.length ], p2 );
            var seg2R = new LineSegment( p2, poly2[ (iPt2+1)%poly2.length ] );
            var seg2LN = norm( perp( sub( seg2L.p2, seg2L.p1 ) ) );
            var seg2RN = norm( perp( sub( seg2R.p2, seg2R.p1 ) ) );
            var p2N = norm( add( seg2LN, seg2RN ) );
            var gradientS2LNonS1R = getGradientForConstraint( seg2LN, seg1R );
            var gradientS2RNonS1R = getGradientForConstraint( seg2RN, seg1R );
            if( dot(p2N, seg1RN)<epsilon && ((gradientS2LNonS1R<epsilon && gradientS2RNonS1R>-epsilon) || (gradientS2LNonS1R>-epsilon && gradientS2RNonS1R<epsilon)) ) {
                // add seg1R as a constraint
                var constraint_segment = getConstraintSegmentFromLineSegmentAndPoint( seg1R, v1, p2, v2 );
                connection.constraints.push( new Constraint( constraint_segment, var2.iPart, iPt2, var1.iPart, iPt1 ) );
            }
            var gradientS1LNonS2R = getGradientForConstraint( seg1LN, seg2R );
            var gradientS1RNonS2R = getGradientForConstraint( seg1RN, seg2R );
            if( dot(p1N,seg2RN)<epsilon && ((gradientS1LNonS2R<epsilon && gradientS1RNonS2R>-epsilon) || (gradientS1LNonS2R>-epsilon && gradientS1RNonS2R<epsilon)) ) {
                // add seg2R as a constraint
                var constraint_segment = getConstraintSegmentFromLineSegmentAndPoint( seg2R, v2, p1, v1 );
                constraint_segment.p1 = reflectXY( constraint_segment.p1 );
                constraint_segment.p2 = reflectXY( constraint_segment.p2 );
                connection.constraints.push( new Constraint( constraint_segment, var1.iPart, iPt1, var2.iPart, iPt2 ) );
            }
        }
    }
    
    addConstraintsFromWalls( connection );
    
    return connection;
}

// -----------------------------------------------------------------------------------

function addConstraintsFromWalls( connection ) {
    var iVar1 = connection.a;
    var iVar2 = connection.b;
    var range1 = getConstraintsFromWalls( iVar1 );
    var range2 = getConstraintsFromWalls( iVar2 );
    variables[ iVar1 ].min_value = range1[0]-20;
    variables[ iVar1 ].max_value = range1[1]+20;
    variables[ iVar2 ].min_value = range2[0]-20;
    variables[ iVar2 ].max_value = range2[1]+20;
    connection.constraints.push( new Constraint( new LineSegment( new Point( range1[0], range2[0] ), new Point( range1[1], range2[0] ) ), 
        variables[ iVar2 ].iPart, range2[2], -1, -1 ) ); // bottom wall
    connection.constraints.push( new Constraint( new LineSegment( new Point( range1[1], range2[0] ), new Point( range1[1], range2[1] ) ), 
        variables[ iVar1 ].iPart, range1[3], -1, -1 ) ); // right wall
    connection.constraints.push( new Constraint( new LineSegment( new Point( range1[1], range2[1] ), new Point( range1[0], range2[1] ) ), 
        variables[ iVar2 ].iPart, range2[3], -1, -1 ) ); // top wall
    connection.constraints.push( new Constraint( new LineSegment( new Point( range1[0], range2[1] ), new Point( range1[0], range2[0] ) ), 
        variables[ iVar1 ].iPart, range1[2], -1, -1 ) ); // left wall
}

// -----------------------------------------------------------------------------------

function getConstraintsFromWalls( iVar ) {
    // we want our variable range to be the from the largest of all the min_vals to the lowest of all the max_vals
    var range = [ -Number.MAX_VALUE, Number.MAX_VALUE, -1, -1 ]; // min_value, max_value, iPtMinValue, iPtMaxValue
    var poly = getInitiallyTransformedPart( variables[ iVar ].iPart );
    var walls = [ [ new Point( 0, 0 ),           new Point( 0, 1 ) ],    // bottom wall (point, normal)
                  [ new Point( 0, 0 ),           new Point( 1, 0 ) ],    // left wall
                  [ new Point( area_width, 0 ),  new Point( -1, 0 ) ],   // right wall
                  [ new Point( 0, area_height ), new Point( 0, -1 ) ] ]; // top wall
    for( var iPt = 0; iPt < poly.length; iPt++ ) {
        for( var iWall = 0; iWall < walls.length; iWall++ ) {
            // TODO: extend to rotations too
            var wallIntersection = lineWithLineIntersection( walls[ iWall ][0], perp( walls[ iWall ][1] ), poly[ iPt ], variables[ iVar ].transform.translation );
            if( !wallIntersection.test ) continue; // (movement parallel to wall)
            var is_min_val = ( dot( walls[ iWall ][1], variables[ iVar ].transform.translation ) > 0 );
            if( is_min_val ) {
                if( wallIntersection.u2 > range[0] ) {
                    range[0] = wallIntersection.u2;
                    range[2] = iPt;
                }
            }
            else {
                if( wallIntersection.u2 < range[1] ) {
                    range[1] = wallIntersection.u2;
                    range[3] = iPt;
                }
            }
        }
    }
    return range;
}

// -----------------------------------------------------------------------------------

function reflectXY(p) {
    return new Point(p.y,p.x);
}

// -----------------------------------------------------------------------------------

function getConstraintSegmentFromLineSegmentAndPoint( segment, v1, p, v2 ) {
    // if the segment moves along v1 and the point along v2,
    // how far along each will they be at the moments where the endpoints intersect with the point?
    var intersection1 = lineWithLineIntersection( segment.p1, v1, p, v2 );
    var intersection2 = lineWithLineIntersection( segment.p2, v1, p, v2 );
    if( !intersection1.test || !intersection2.test )
        return null; // v1 and v2 are parallel
    return new LineSegment( new Point( intersection2.u1, intersection2.u2 ),
                            new Point( intersection1.u1, intersection1.u2 ) );
}

// -----------------------------------------------------------------------------------

function initWithTrucks( numTrucksWanted ) {
    var truck_width = 60;
    var truck_height = 40;
    var truck_top = 200;
    
    N_VARIABLES = numTrucksWanted;
    N_PARTS = N_VARIABLES; // (for now each part has a single degree of freedom)

    // each part is a polygon, centered at its rotation point
    parts = new Array( N_PARTS );
    for( var iPart = 0; iPart < N_PARTS; iPart++ ) {
        var poly = [ new Point(-truck_width/2,-truck_height/2), new Point(truck_width/2,-truck_height/2),
                     new Point(truck_width/2,truck_height/2),   new Point(-truck_width/2,truck_height/2) ];
        var initial_transform = new Transform( 0, new Point(0,truck_top) );
        var label = String.fromCharCode( 65 + iPart );
        var variables_that_affect_us = [ iPart ];
        parts[iPart] = new Part( label, poly, initial_transform, variables_that_affect_us );
    }

    // each variable applies to a part, and transforms it in some way
    variables = new Array(N_VARIABLES);
    for( var iVariable = 0; iVariable < N_VARIABLES; iVariable++ ) {
        var initial_value = (iVariable+1) * area_width / (N_PARTS+1);
        var transform = new Transform( 0, new Point(1,0) );
        var iPart = iVariable;
        var label = parts[ iPart ].label; // (if this part had more than one variable then would need to disambiguate)
        var min_value = 0;
        var max_value = area_width;
        variables[iVariable] = new Variable( label, iPart, initial_value, transform, min_value, max_value );
    }    

    N_CONNECTIONS = N_PARTS-1;

    // stop the trucks passing through each other or the wall
    connections = new Array(N_CONNECTIONS);
    for( var i = 0; i < N_CONNECTIONS; i++ ) {
        // DEBUG - want to do this but need to deal with parallel moves first
        //connections[i] = computeConstraints(i,i+1);
        //continue;
        
        connections[i] = new Connection(i,i+1); 
        if( N_CONNECTIONS == 1 ) {
            var leftWall = new Constraint( new LineSegment( new Point( truck_width/2, area_width - truck_width/2 ),
                                                            new Point( truck_width/2, truck_width + truck_width/2 ) ),
                                           0,0,0,0 ); // TODO
            connections[i].constraints.push( leftWall );
            var trucksPush = new Constraint( new LineSegment( new Point( truck_width/2, truck_width + truck_width/2 ),
                                                              new Point( area_width - truck_width*3/2, area_width - truck_width/2) ),
                                           0,0,0,0 ); // TODO );
            connections[i].constraints.push( trucksPush );
            var rightWall = new Constraint( new LineSegment( new Point( area_width - truck_width*3/2, area_width-truck_width/2 ),
                                                             new Point( truck_width/2, area_width-truck_width/2 ) ),
                                           0,0,0,0 ); // TODO );
            connections[i].constraints.push( rightWall );
        }
        else if( i == 0 ) {
            var leftWall = new Constraint( new LineSegment( new Point( truck_width/2, area_width - truck_width/2 ),
                                                            new Point( truck_width/2, truck_width + truck_width/2 ) ),
                                           0,0,0,0 ); // TODO );
            connections[i].constraints.push( leftWall );
            var trucksPush = new Constraint( new LineSegment( new Point( truck_width/2, truck_width + truck_width/2 ),
                                                              new Point( area_width - truck_width*3/2, area_width - truck_width/2) ),
                                           0,0,0,0 ); // TODO );
            connections[i].constraints.push( trucksPush );
        }
        else if( i == N_CONNECTIONS-1 ) {
            var trucksPush = new Constraint( new LineSegment( new Point( truck_width/2, truck_width + truck_width/2 ),
                                                              new Point( area_width - truck_width*3/2, area_width - truck_width/2 ) ),
                                           0,0,0,0 ); // TODO );
            connections[i].constraints.push( trucksPush );
            var rightWall = new Constraint( new LineSegment( new Point( area_width - truck_width*3/2, area_width-truck_width/2 ),
                                                             new Point( truck_width/2, area_width-truck_width/2 ) ),
                                           0,0,0,0 ); // TODO );
            connections[i].constraints.push( rightWall );
        }
        else {
            var trucksPush = new Constraint( new LineSegment( new Point(truck_width/2,truck_width+truck_width/2),
                                                              new Point(area_width-truck_width*3/2,area_width-truck_width/2) ),
                                           0,0,0,0 ); // TODO );
            connections[i].constraints.push( trucksPush );
        }
    }
}
    
// -----------------------------------------------------------------------------------

function initWithTest() {
    var numTrucksWanted = 2;
    var truck_width = 60;
    var truck_height = 40;
    var truck_top = 200;
    
    N_VARIABLES = numTrucksWanted;
    N_PARTS = N_VARIABLES; // (for now each part has a single degree of freedom)

    // each part is a polygon, centered at its rotation point
    parts = new Array( N_PARTS );
    for( var iPart = 0; iPart < N_PARTS; iPart++ ) {
        var poly = [ new Point(-truck_width/2,-truck_height/2), new Point(truck_width/2,-truck_height/2),
                     new Point(truck_width/2,truck_height/2),   new Point(-truck_width/2,truck_height/2) ];
        var initial_transform = new Transform( 0, new Point(0,truck_top) );
        var label = String.fromCharCode( 65 + iPart );
        var variables_that_affect_us = [ iPart ];
        parts[iPart] = new Part( label, poly, initial_transform, variables_that_affect_us );
    }

    // each variable applies to a part, and transforms it in some way
    variables = new Array(N_VARIABLES);
    for( var iVariable = 0; iVariable < N_VARIABLES; iVariable++ ) {
        var initial_value = (iVariable+1) * area_width / (N_PARTS+1);
        var transform = new Transform( 0, new Point(1,0) );
        var iPart = iVariable;
        var label = parts[ iPart ].label; // (if this part had more than one variable then would need to disambiguate)
        var min_value = 0;
        var max_value = area_width;
        variables[iVariable] = new Variable( label, iPart, initial_value, transform, min_value, max_value );
    }    

    N_CONNECTIONS = N_PARTS-1;

    // stop the trucks passing through each other or the wall
    connections = new Array(N_CONNECTIONS);
    for( var i = 0; i < N_CONNECTIONS; i++ ) {
        // DEBUG - want to do this but need to deal with parallel moves first
        //connections[i] = computeConstraints(i,i+1);
        //continue;
        
        connections[i] = new Connection(i,i+1); 
        /*if( N_CONNECTIONS == 1 ) {
            var leftWall = new Constraint( new LineSegment( new Point( truck_width/2, area_width - truck_width/2 ),
                                                            new Point( truck_width/2, truck_width + truck_width/2 ) ),
                                           0,0,0,0 ); // TODO
            group.constraints.push( leftWall );
            var trucksPush = new Constraint( new LineSegment( new Point( truck_width/2, truck_width + truck_width/2 ),
                                                              new Point( area_width - truck_width*3/2, area_width - truck_width/2) ),
                                           0,0,0,0 ); // TODO );
            group.constraints.push( trucksPush );
            var rightWall = new Constraint( new LineSegment( new Point( area_width - truck_width*3/2, area_width-truck_width/2 ),
                                                             new Point( truck_width/2, area_width-truck_width/2 ) ),
                                           0,0,0,0 ); // TODO );
            group.constraints.push( rightWall );
        }
        else if( i == 0 ) {
            var leftWall = new Constraint( new LineSegment( new Point( truck_width/2, area_width - truck_width/2 ),
                                                            new Point( truck_width/2, truck_width + truck_width/2 ) ),
                                           0,0,0,0 ); // TODO );
            group.constraints.push( leftWall );
            var trucksPush = new Constraint( new LineSegment( new Point( truck_width/2, truck_width + truck_width/2 ),
                                                              new Point( area_width - truck_width*3/2, area_width - truck_width/2) ),
                                           0,0,0,0 ); // TODO );
            group.constraints.push( trucksPush );
        }
        else if( i == N_CONNECTIONS-1 ) {
            var trucksPush = new Constraint( new LineSegment( new Point( truck_width/2, truck_width + truck_width/2 ),
                                                              new Point( area_width - truck_width*3/2, area_width - truck_width/2 ) ),
                                           0,0,0,0 ); // TODO );
            group.constraints.push( trucksPush );
            var rightWall = new Constraint( new LineSegment( new Point( area_width - truck_width*3/2, area_width-truck_width/2 ),
                                                             new Point( truck_width/2, area_width-truck_width/2 ) ),
                                           0,0,0,0 ); // TODO );
            group.constraints.push( rightWall );
        }
        else*/ {
            var trucksPush = new Constraint( new LineSegment( new Point(truck_width/2,truck_width+truck_width/2),
                                                              new Point(area_width-truck_width*3/2,area_width-truck_width/2) ),
                                           0,0,0,0 ); // TODO );
            connections[i].constraints.push( trucksPush );
        }
    }
}
    
// -----------------------------------------------------------------------------------

canvas.addEventListener('mousedown', function(evt) {
    var mousePos = getMousePos(canvas, evt);
    // if within a shape then make it the driver
    if( pointInRect( mousePos, getAreaRect() ) ) {
        var areaPos = projectScreenToArea( mousePos );
        var iVariable = getVariableHandleByAreaPos( areaPos );
        if( iVariable >= 0 ) {
            iDrivenVariable = iVariable;
            grabPos = areaPos;
            isDragging = true;
            draw();
            drawVariableHandle( iDrivenVariable, areaPos );
            return;
        }
    }
    // if on a plot then set those variables directly
    for( var iPlotConnection = 0; iPlotConnection < N_CONNECTIONS; iPlotConnection++ ) {
        if( pointInRect( mousePos, getPlotRect( iPlotConnection ) ) ) {
            var plotPos = projectScreenToPlot( mousePos, iPlotConnection );
            var connection = connections[ iPlotConnection ];
            variables[ connection.a ].value = plotPos.x;
            variables[ connection.b ].value = plotPos.y;
            draw();
            return;
        }
    }
}, false);

// -----------------------------------------------------------------------------------

canvas.addEventListener('mousemove', function(evt) {
    var mousePos = getMousePos(canvas, evt);
    var areaPos = projectScreenToArea( mousePos );
    if( isDragging && iDrivenVariable >= 0 ) {
        currentMousePositionAccepted = tryMoveDriver( grabPos, areaPos );
        if( currentMousePositionAccepted ) {
            grabPos = areaPos;
            // TODO: this is not quite right - the truck might have moved a little even if was blocked from going the whole way
            //       result is slight cursor drift from the attachment point
        }
    }
    else {
        // TODO: if moving over a constraint, highlight it
        iDrivenVariable = getVariableHandleByAreaPos( areaPos );
        currentMousePositionAccepted = true;
    }
    draw();
    drawVariableHandle( iDrivenVariable, areaPos );
}, false);

// -----------------------------------------------------------------------------------

canvas.addEventListener('mouseup', function(evt) {
    isDragging = false;
    currentMousePositionAccepted = true;
    var mousePos = getMousePos(canvas, evt);
    var areaPos = projectScreenToArea( mousePos );
    iDrivenVariable = getVariableHandleByAreaPos( areaPos );
    draw();
    drawVariableHandle( iDrivenVariable, areaPos );
}, false);

// -----------------------------------------------------------------------------------

function getVariableHandleByAreaPos( areaPos ) {
    for( var iVariable = N_VARIABLES-1; iVariable >= 0; iVariable-- ) {
        if( pointInPolygon( getTransformedPart( variables[ iVariable ].iPart ), areaPos ) )
            return iVariable;
    }
    return -1;
}

// -----------------------------------------------------------------------------------

function getInitiallyTransformedPart( iPart ) {
    var tp = [];
    var part = parts[ iPart ];
    for( var iPt = 0; iPt < part.poly.length; iPt++ ) {
        tp.push( applyTransform( part.poly[iPt], part.initial_transform, 1 ) );
    }
    return tp;
}

// -----------------------------------------------------------------------------------

function getTransformedPart( iPart ) {
    var tp = [];
    var part = parts[ iPart ];
    for( var iPt = 0; iPt < part.poly.length; iPt++ ) {
        tp.push( applyPartTransform( iPart, part.poly[iPt] ) );
    }
    return tp;
}

// -----------------------------------------------------------------------------------

function projectAreaToScreen( p ) {
    return new Point( p.x + margin, margin + area_height - p.y );
}

// -----------------------------------------------------------------------------------

function projectScreenToArea( sp ) {
    return new Point( sp.x - margin, margin + area_height - sp.y );
}

// -----------------------------------------------------------------------------------

function getPlotSizeInPixels() {
    return Math.min( canvas.width - area_width - margin*3, ( canvas.height - (N_CONNECTIONS+1)*margin ) / N_CONNECTIONS );
}

// -----------------------------------------------------------------------------------

function projectPlotToScreen( p, i ) {
    var varX = variables[ connections[ i ].a ];
    var varY = variables[ connections[ i ].b ];
    var min_x = varX.min_value;
    var max_x = varX.max_value;
    var min_y = varY.min_value;
    var max_y = varY.max_value;
    var plot_size = getPlotSizeInPixels();
    return new Point( plot_size * ( p.x - min_x ) / ( max_x - min_x ) + area_width + margin*2, 
                      i*(margin+plot_size) + margin + plot_size - plot_size * ( p.y - min_y ) / ( max_y - min_y ) );
}

// -----------------------------------------------------------------------------------

function projectScreenToPlot( sp, i ) {
    var varX = variables[ connections[ i ].a ];
    var varY = variables[ connections[ i ].b ];
    var min_x = varX.min_value;
    var max_x = varX.max_value;
    var min_y = varY.min_value;
    var max_y = varY.max_value;
    var plot_size = getPlotSizeInPixels();
    return new Point( ( sp.x - margin*2 - area_width ) * ( max_x - min_x ) / plot_size + min_x,
                      ( sp.y - margin - i*(margin+plot_size) - plot_size ) * ( max_y - min_y ) / ( -plot_size ) + min_y );
}

// -----------------------------------------------------------------------------------

function draw() {
    // show the limit of the canvas itself
    context.beginPath();
    context.rect(0, 0, canvas.width, canvas.height);
    context.fillStyle = '#F0F0F0';
    context.fill();
    
    // show the collision area
    var area_rect = getAreaRect();
    context.beginPath();
    context.rect( area_rect.x, area_rect.y, area_rect.w, area_rect.h );
    context.fillStyle = 'white';
    context.fill();
    context.lineWidth = 1;
    context.strokeStyle = 'black';
    context.stroke();
    
    // draw each part
    for( var iPart = 0; iPart < N_PARTS; iPart++ ) {
        drawPart( iPart );
    }

    // plot
    for( var iPlotConnection = 0; iPlotConnection < N_CONNECTIONS; iPlotConnection++ ) {
        drawPlot( iPlotConnection );
    }
}

// -----------------------------------------------------------------------------------

function drawPlot( iPlotConnection ) {
    var connection = connections[ iPlotConnection ];
    var varX = variables[ connection.a ];
    var varY = variables[ connection.b ];
    // blank the plot area
    var plot_rect = getPlotRect( iPlotConnection );
    context.beginPath();
    context.rect( plot_rect.x, plot_rect.y, plot_rect.w, plot_rect.h );
    context.fillStyle = 'white';
    context.fill();
    context.save();
    context.clip();
    // label the axes
    var horiz_axis_label_pos = new Point( plot_rect.x + plot_rect.w/2, plot_rect.y + plot_rect.h );
    var vert_axis_label_pos = new Point( plot_rect.x, plot_rect.y + plot_rect.h/2 );
    context.font = "12px Arial";
    if( connection.a == iDrivenVariable ) {
        if( currentMousePositionAccepted )
            context.fillStyle = 'limegreen';
        else
            context.fillStyle = 'red';
    }
    else
        context.fillStyle = "black";
    context.textAlign = "center";
    context.textBaseline = "bottom";
    context.fillText( varX.label, horiz_axis_label_pos.x, horiz_axis_label_pos.y );
    if( connection.b == iDrivenVariable ) {
        if( currentMousePositionAccepted )
            context.fillStyle = 'limegreen';
        else
            context.fillStyle = 'red';
    }
    else
        context.fillStyle = "black";
    context.textAlign = "left";
    context.textBaseline = "middle";
    context.fillText( varY.label, vert_axis_label_pos.x, vert_axis_label_pos.y );
    // draw the current state as a blue dot
    var p = new Point( varX.value, varY.value );
    var pp = projectPlotToScreen( p, iPlotConnection );
    context.beginPath();
    context.arc(pp.x, pp.y, 3, 0, 2*Math.PI);
    context.fillStyle = 'blue';
    context.fill();
    // draw the constraints
    for( var iConstraint = 0; iConstraint < connection.constraints.length; iConstraint++) {
        var constraint_segment = connection.constraints[ iConstraint ].segment;
        var highlighted = (iPlotConnection==iHighlightedConnection) && (iConstraint==iHighlightedConstraint);
        drawConstraint( constraint_segment, iPlotConnection, highlighted );
    }
    context.restore();
}

// -----------------------------------------------------------------------------------

function getAreaRect() {
    var top_left = projectAreaToScreen( new Point( 0, area_height ) );
    var bottom_right = projectAreaToScreen( new Point( area_width, 0 ) );
    return { x:top_left.x, y:top_left.y, w:bottom_right.x-top_left.x, h:bottom_right.y-top_left.y };
}

// -----------------------------------------------------------------------------------

function getPlotRect( iPlotConnection ) {
    var connection = connections[ iPlotConnection ];
    var varX = variables[ connection.a ];
    var varY = variables[ connection.b ];
    var top_left = projectPlotToScreen( new Point( varX.min_value, varY.max_value ), iPlotConnection );
    var bottom_right = projectPlotToScreen( new Point( varX.max_value, varY.min_value ), iPlotConnection );
    return { x:top_left.x, y:top_left.y, w:bottom_right.x-top_left.x, h:bottom_right.y-top_left.y };
}

// -----------------------------------------------------------------------------------

function drawPart( iPart ) {
    var part = parts[ iPart ];
    
    var poly = getTransformedPart( iPart );
    if( part.variables_that_affect_us.indexOf( iDrivenVariable ) >= 0 ) {
        if( currentMousePositionAccepted )
            context.fillStyle = 'limegreen';
        else
            context.fillStyle = 'red';
    }
    else
        context.fillStyle = 'grey';
    context.beginPath();
    var centroid = new Point(0,0);
    for( var iPt = 0; iPt < poly.length; iPt++ ) {
        var p = projectAreaToScreen( poly[ iPt ] );
        if( iPt == 0 )
            context.moveTo( p.x, p.y );
        else
            context.lineTo( p.x, p.y );
        centroid = add( centroid, p );
    }
    centroid = div( centroid, poly.length );
    context.closePath();
    context.fill();
    context.lineWidth = 1;
    context.strokeStyle = 'black';
    context.stroke();
    
    // draw the label
    context.font = "30px Arial";
    context.textAlign = "center";
    context.fillStyle = "black";
    context.textBaseline="middle"; 
    context.fillText( part.label, centroid.x, centroid.y );
    
    // draw the highlighted vertex and segment
    if( iHighlightedConnection >= 0 && iHighlightedConstraint >=0 ) {
        var highlighted_constraint = connections[ iHighlightedConnection ].constraints[ iHighlightedConstraint ];
        if( highlighted_constraint.iPart1 == iPart ) {
            var p = projectAreaToScreen( poly[ highlighted_constraint.iPt1 ] );
            context.fillStyle = 'blue';
            context.beginPath();
            context.arc( p.x, p.y, 3, 0, 2*Math.PI );
            context.fill();
        }
        if( highlighted_constraint.iPart2 == iPart ) {
            var p1 = projectAreaToScreen( poly[ highlighted_constraint.iSeg2 ] );
            var p2 = projectAreaToScreen( poly[ (highlighted_constraint.iSeg2+1)%poly.length ] );
            context.strokeStyle = 'blue';
            context.lineWidth = 2;
            context.beginPath();
            context.moveTo( p1.x, p1.y );
            context.lineTo( p2.x, p2.y );
            context.stroke();
        }
    }
}

// -----------------------------------------------------------------------------------

function applyPartTransform( iPart, p ) {
    var part = parts[ iPart ];
    // first apply the rotations
    var cp = rotate( p, part.initial_transform.rotation );
    for( var iiVariable = 0; iiVariable < part.variables_that_affect_us.length; iiVariable++ ) {
        var iVariable = part.variables_that_affect_us[ iiVariable ];
        var variable = variables[ iVariable ];
        cp = rotate( cp, variable.transform.rotation * variable.value );
    }
    // then apply translations
    cp = add( cp, part.initial_transform.translation );
    for( var iiVariable = 0; iiVariable < part.variables_that_affect_us.length; iiVariable++ ) {
        var iVariable = part.variables_that_affect_us[ iiVariable ];
        var variable = variables[ iVariable ];
        cp = add( cp, mul( variable.transform.translation, variable.value ) );
    }
    return cp;
}

// -----------------------------------------------------------------------------------

function applyInversePartTransform( iPart, p ) {
    var part = parts[ iPart ];
    // first apply inverse translations
    var cp = add( p, mul( part.initial_transform.translation, -1 ) );
    for( var iiVariable = 0; iiVariable < part.variables_that_affect_us.length; iiVariable++ ) {
        var iVariable = part.variables_that_affect_us[ iiVariable ];
        var variable = variables[ iVariable ];
        cp = add( cp, mul( variable.transform.translation, -variable.value ) );
    }
    // then apply the inverse rotations
    cp = rotate( cp, -part.initial_transform.rotation );
    for( var iiVariable = 0; iiVariable < part.variables_that_affect_us.length; iiVariable++ ) {
        var iVariable = part.variables_that_affect_us[ iiVariable ];
        var variable = variables[ iVariable ];
        cp = rotate( cp, variable.transform.rotation * -variable.value );
    }
    return cp;
}

// -----------------------------------------------------------------------------------

function applyPartTransformWithChangedVariable( iPart, p, iVar, value ) {
    var part = parts[ iPart ];
    // first apply the rotations
    var cp = rotate( p, part.initial_transform.rotation );
    for( var iiVariable = 0; iiVariable < part.variables_that_affect_us.length; iiVariable++ ) {
        var iVariable = part.variables_that_affect_us[ iiVariable ];
        var variable = variables[ iVariable ];
        var value_to_use = (iVariable==iVar)?value:variable.value;
        cp = rotate( cp, variable.transform.rotation * value_to_use );
    }
    // then apply translations
    cp = add( cp, part.initial_transform.translation );
    for( var iiVariable = 0; iiVariable < part.variables_that_affect_us.length; iiVariable++ ) {
        var iVariable = part.variables_that_affect_us[ iiVariable ];
        var variable = variables[ iVariable ];
        var value_to_use = (iVariable==iVar)?value:variable.value;
        cp = add( cp, mul( variable.transform.translation, value_to_use ) );
    }
    return cp;
}

// -----------------------------------------------------------------------------------

function drawVariableHandle( iVariable, areaPos ) {
    if( iVariable < 0 ) return;
    var variable = variables[ iVariable ];
    
    context.lineWidth = 1;
    context.strokeStyle = 'black';
    
    // show where this point would move to
    var pp = applyInversePartTransform( variable.iPart, areaPos );
    var arrow_length_in_variable_units = ( variable.max_value - variable.min_value ) * 0.05;
    var p1 = applyPartTransformWithChangedVariable( variable.iPart, pp, iVariable, variable.value + arrow_length_in_variable_units );
    var p2 = applyPartTransformWithChangedVariable( variable.iPart, pp, iVariable, variable.value - arrow_length_in_variable_units );
    var sp = projectAreaToScreen( areaPos );
    var sp1 = projectAreaToScreen( p1 );
    var sp2 = projectAreaToScreen( p2 );
    
    drawArrow( sp, sp1 );
    drawArrow( sp, sp2 );
    
    return;
}

// -----------------------------------------------------------------------------------

function drawArrow( from, to ) {
    var headlen = 10; // length of head in pixels
    var angle = Math.atan2( to.y - from.y, to.x - from.x );

    context.beginPath();
    context.moveTo( from.x, from.y );
    context.lineTo( to.x, to.y );
    context.stroke();

    context.beginPath();
    context.moveTo( to.x - headlen * Math.cos( angle - Math.PI/6 ), to.y - headlen * Math.sin( angle - Math.PI/6 ) );
    context.lineTo( to.x, to.y );
    context.lineTo( to.x - headlen * Math.cos( angle + Math.PI/6 ), to.y - headlen * Math.sin( angle + Math.PI/6 ) );
    context.stroke();
}

// -----------------------------------------------------------------------------------

function drawConstraint( constraint, iPlotConnection, highlighted ) {
    var a = projectPlotToScreen( constraint.p1, iPlotConnection );
    var b = projectPlotToScreen( constraint.p2, iPlotConnection );

    context.beginPath();
    context.moveTo( a.x, a.y );
    context.lineTo( b.x, b.y );
    if( highlighted ) {
        context.lineWidth = 2;
        context.strokeStyle = 'blue';
    }
    else {
        context.lineWidth = 1;
        context.strokeStyle = 'black';
    }
    context.stroke();
    var d = 8;
    var n = norm( perp( sub( b, a ) ) );
    var offset = mul( n, d/2 );
    var oa = add( a, offset );
    var ob = add( b, offset );
    context.beginPath();
    context.moveTo( oa.x, oa.y );
    context.lineTo( ob.x, ob.y );
    context.lineWidth = d;
    context.strokeStyle = 'rgba(0,0,0,0.1)';
    context.stroke();
}

// -----------------------------------------------------------------------------------

// return true if we were able to perform the whole move
function tryMoveDriver( grabPos, mousePos ) {
    iHighlightedConnection = iHighlightedConstraintGroup = iHighlightedConstraint = -1;
    var variable = variables[ iDrivenVariable ];
    var arrow_length_in_variable_units = ( variable.max_value - variable.min_value ) * 0.05;
    var pp = applyInversePartTransform( variable.iPart, grabPos );
    var p1 = applyPartTransformWithChangedVariable( variable.iPart, pp, iDrivenVariable, variable.value + arrow_length_in_variable_units );
    var p2 = applyPartTransformWithChangedVariable( variable.iPart, pp, iDrivenVariable, variable.value - arrow_length_in_variable_units );
    var new_value = null;
    if( dist( mousePos, p1 ) < dist( mousePos, p2 ) ) {
        // move in p1 direction (+ve)
        var a = sub( mousePos, grabPos );
        var b = sub( p1, grabPos );
        new_value = variable.value + dot( a, norm( b ) ) * arrow_length_in_variable_units / len( b );
    }
    else {
        // move in p2 direction (-ve)
        var a = sub( mousePos, grabPos );
        var b = sub( p2, grabPos );
        new_value = variable.value - dot( a, norm( b ) ) * arrow_length_in_variable_units / len( b );
    }
    
    return tryChangeVariable( iDrivenVariable, new_value );
}

// -----------------------------------------------------------------------------------

function tryChangeVariable( iVariable, new_value ) {
    var from = new Array( N_VARIABLES );
    var to = new Array( N_VARIABLES );
    while( Math.abs( variables[ iVariable ].value - new_value ) > epsilon ) {
        // find the safe linear path that takes us some way, but break if one doesn't exist
        for( var i = 0; i < N_VARIABLES; i++ ) {
            from[ i ] = variables[ i ].value;
            to[ i ] = ( i == iVariable ) ? new_value : from[ i ];
        }
        var path_result = getSafeLinearPath( from, to );
        if( !path_result.exists )
            return false; // we are jammed at this location and can go no further
        // apply the move
        for( var i = 0; i < N_VARIABLES; i++ ) {
            variables[ i ].value = path_result.new_location[ i ];
        }
    }
    return true;
}

// -----------------------------------------------------------------------------------

function getSafeLinearPath( from, to ) {
    var cr = findFirstConstraintCollision( from, to );
    switch( cr.outcome ) {
        case CollisionOutcome.MISS:
            // this whole path is safe
            return { exists:true, new_location:to };
        case CollisionOutcome.NOT_REACHED_YET: 
            // can safely move forwards a little
            return { exists:true, new_location:cr.new_location };
        case CollisionOutcome.FRICTION_JAM:
        case CollisionOutcome.CORNER_JAM:
            // cannot move any further
            return { exists:false }; 
        case CollisionOutcome.SLIDE:
            // TODO: test this linear segment against all the other constraints (recurse down?)
            return { exists:true, new_location:cr.new_location }; // for now just allow it
        default:
            throw new Error('Unrecognised collision outcome.');
    }
}

// -----------------------------------------------------------------------------------

function findFirstConstraintCollision( from, to ) {
    // Find the first constraint that intersects this change
    // returns: outcome: { CollisionOutcome, new_location:float[N_VARIABLES] }
    var first_collision = { outcome:CollisionOutcome.MISS, new_location:new Array( N_VARIABLES ) };
    var closest_dist = Number.MAX_VALUE;
    for( var iConnection = 0; iConnection < N_CONNECTIONS; iConnection++ ) {
        var connection = connections[ iConnection ];
        var move = new LineSegment( new Point( from[ connection.a ], from[ connection.b ] ), new Point( to[ connection.a ], to[ connection.b ] ) );
        for( var iConstraint = 0; iConstraint < connection.constraints.length; iConstraint++ ) {
            var cr = testConstraint( move, connection.constraints[ iConstraint ] );
            if( cr.outcome == CollisionOutcome.MISS ) continue;
            if( cr.outcome == CollisionOutcome.ALREADY_AT_END ) {
                // TODO: decide if this is a MISS or a CORNER_JAM
                cr.outcome = CollisionOutcome.CORNER_JAM; // (for now)
            }
            var d = dist( cr.point, move.p1 );
            if( d < closest_dist ) {
                closest_dist = d;
                first_collision.outcome = cr.outcome;
                for( var i = 0; i < N_VARIABLES; i++ )
                    first_collision.new_location[ i ] = from[ i ];
                first_collision.new_location[ connection.a ] = cr.point.x;
                first_collision.new_location[ connection.b ] = cr.point.y;
                // show the user what is happening
                iHighlightedConnection = iConnection;
                iHighlightedConstraint = iConstraint;
            }
        }
    }
    return first_collision;
}

// -----------------------------------------------------------------------------------

function testConstraint( move, constraint ) {
    // move: a LineSegment in the a,b coordinates of constraint
    // constraint: a Constraint
    // returns: outcome:CollisionOutcome, point:final Point after collision or slide
    
    // a move is a collision if:
    // 1. the move segment intersects the constraint segment, and
    // 2. the end of the move is behind the constraint segment, and
    // 3. the start of the move is not behind the constraint segment
    var intersection = lineSegmentsIntersection( move, constraint.segment );
    var endIsBehind = isBehind( move.p2, constraint.segment );
    var startIsBehind = isBehind( move.p1, constraint.segment );
    if( !intersection.test || !endIsBehind || startIsBehind ) {
        // no collision
        return { outcome:CollisionOutcome.MISS, point:move.p2 };
    }
    if( dist( move.p1, intersection.point ) > epsilon ) {
        return { outcome:CollisionOutcome.NOT_REACHED_YET, point:intersection.point };
    }
    var gradient = getGradientForConstraint( sub( move.p2, move.p1 ), constraint.segment );
    if( Math.abs( gradient ) < minGradient ) {
        // friction jam
        return { outcome:CollisionOutcome.FRICTION_JAM, point:move.p1 };
    }
    var slide_intersection = lineSegmentWithLineIntersection( constraint.segment, move.p2, perp( sub( move.p2, move.p1 ) ) );
    if( slide_intersection.test ) {
        // partial slide
        return { outcome:CollisionOutcome.SLIDE, point:slide_intersection.point };
    }
    var slideEnd = null;
    if( gradient < 0 ) {
        slideEnd = constraint.segment.p1;
    }
    else {
        slideEnd = constraint.segment.p2;
    }
    if( dist( slideEnd, move.p1 ) < epsilon ) {
        return { outcome:CollisionOutcome.ALREADY_AT_END, point:move.p1 };
    }
    return { outcome:CollisionOutcome.SLIDE, point:slideEnd };
}

// -----------------------------------------------------------------------------------

function getMousePos(canvas, evt) {
    var rect = canvas.getBoundingClientRect();
    return {
        x: evt.clientX - rect.left,
        y: evt.clientY - rect.top
    };
}

// -----------------------------------------------------------------------------------

function isBehind( point, constraint ) {
    var dp = dot( norm( sub( point, constraint.p1 ) ), norm( perp( sub( constraint.p2, constraint.p1 ) ) ) );
    return dp < -epsilon; // (allow for floating point issues)
}

// -----------------------------------------------------------------------------------

function dist( a, b ) {
    return len( sub( a, b ) );
}

// -----------------------------------------------------------------------------------

function len( v ) {
    return Math.hypot( v.x, v.y );
}

// -----------------------------------------------------------------------------------

function perp( v ) {
    return new Point( -v.y, v.x );
}

// -----------------------------------------------------------------------------------

function norm( v ) {
    return div( v, len( v ) );
}

// -----------------------------------------------------------------------------------

function add( a, b ) {
    return new Point( a.x + b.x, a.y + b.y );
}

// -----------------------------------------------------------------------------------

function sub( a, b ) {
    return new Point( a.x - b.x, a.y - b.y );
}

// -----------------------------------------------------------------------------------

function mul( a, f ) {
    return new Point( a.x * f, a.y * f );
}

// -----------------------------------------------------------------------------------

function div( a, f ) {
    return new Point( a.x / f, a.y / f );
}

// -----------------------------------------------------------------------------------

function dot( a, b ) {
    return a.x * b.x + a.y * b.y;
}

// -----------------------------------------------------------------------------------

function lerp( a, b, u ) {
    return add( a, mul( sub( b, a ), u ) );
}

// -----------------------------------------------------------------------------------

function pointInRect( p, r ) {
    return p.x >= r.x && p.x <= r.x + r.w && p.y >= r.y && p.y <= r.y + r.h;
}

// -----------------------------------------------------------------------------------

function isPointOnLineSegment(p,s) {
    // if AB == AC + BC then C lies on the line segment AB
    var sl = dist( s.p2, s.p1 );
    var a = dist( p, s.p1 );
    var b = dist( p, s.p2 );
    return Math.abs( sl - a - b ) < epsilon;
}

// -----------------------------------------------------------------------------------

function lineSegmentsIntersection(s1,s2) {
    var cr = lineWithLineIntersection( s1.p1, sub( s1.p2, s1.p1 ), s2.p1, sub( s2.p2, s2.p1 ) );
    //if( !cr.test || cr.u1 < 0 || cr.u1 > 1 || cr.u2 < 0 || cr.u2 > 1 ) return { test:false };
    if( !cr.test || cr.u1 < -epsilon || cr.u1 > 1+epsilon || cr.u2 < -epsilon || cr.u2 > 1+epsilon ) return { test:false };
    var p = lerp( s1.p1, s1.p2, cr.u1 );
    return { test:true, point:p };
}

// -----------------------------------------------------------------------------------

function lineSegmentWithLineIntersection( s, p2, v2 ) {
    var cr = lineWithLineIntersection( s.p1, sub( s.p2, s.p1 ), p2, v2 );
    //if( !cr.test || cr.u1 < 0 || cr.u1 > 1 ) return { test:false };
    if( !cr.test || cr.u1 < -epsilon || cr.u1 > 1+epsilon ) return { test:false };
    var p = lerp( s.p1, s.p2, cr.u1 );
    return { test:true, point:p };
}

// -----------------------------------------------------------------------------------

function lineWithLineIntersection( u0, v0, u1, v1 ) {
    // http://stackoverflow.com/a/4977569/126823
    var x00 = u0.x;
    var y00 = u0.y;
    var x10 = u1.x;
    var y10 = u1.y;
    var x01 = v0.x;
    var y01 = v0.y;
    var x11 = v1.x;
    var y11 = v1.y;
    var det = x11 * y01 - x01 * y11;
    if( Math.abs( det ) < epsilon ) {
        return { test:false }; // lines parallel or colinear
    }
    var t = -(-(x00-x10)*y11 + (y00-y10)*x11 ) / det;    // ip = u0 + t*v0
    var s =  ( (x00-x10)*y01 - (y00-y10)*x01 ) / det;    // ip = u1 + s*v1
    return { test:true, u1:t, u2:s };
}

// -----------------------------------------------------------------------------------

function getGradientForConstraint( v, constraint ) {
    return dot( norm( v ), norm( sub( constraint.p2, constraint.p1 ) ) ); // 0 = perpendicular, -ve = sliding left, +ve = sliding right
}

// -----------------------------------------------------------------------------------

function pointInPolygon(poly, pt)
{
    var inside = false;
    var i, j;
    for( i = 0, j = poly.length-1; i < poly.length; j = i++) {
        if( ( ( poly[i].y > pt.y ) != ( poly[j].y > pt.y ) ) && 
            ( pt.x < ( poly[j].x - poly[i].x ) * ( pt.y - poly[i].y ) / ( poly[j].y - poly[i].y ) + poly[i].x ) ) 
        {
            inside = !inside;
        }
    }
    return inside;
}

// -----------------------------------------------------------------------------------

function applyTransform( p, transform, amount ) {
    return add( rotate( p, amount*transform.rotation ), mul( transform.translation, amount ) );
}

// -----------------------------------------------------------------------------------

function rotate( p, theta ) {
    return new Point( Math.cos(theta)*p.x - Math.sin(theta)*p.y, 
                      Math.sin(theta)*p.x + Math.cos(theta)*p.y );
}

// -----------------------------------------------------------------------------------

</script>
</body>
</html>
